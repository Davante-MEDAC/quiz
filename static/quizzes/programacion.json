{
  "id": "programacion",
  "title": "Programaci√≥n",
  "description": "Cuestionario sobre los fundamentos de la programaci√≥n, elementos de un programa inform√°tico y programaci√≥n estructurada.",
  "icon": "üë©üèª‚Äçüíª",
  "lessons": [
    {
      "name": "Fundamentos de Programaci√≥n",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia principal entre datos e informaci√≥n seg√∫n el documento?",
          "options": [
            "Los datos son digitales y la informaci√≥n es anal√≥gica",
            "Los datos tienen significado puntual, la informaci√≥n resulta del procesamiento e interrelaci√≥n de datos",
            "Los datos son n√∫meros y la informaci√≥n son palabras",
            "No hay diferencia, son sin√≥nimos"
          ],
          "correctAnswer": 1,
          "explanation": "Seg√∫n el documento, los datos tienen un significado puntual mientras que la informaci√≥n resulta del procesamiento, interpretaci√≥n e interrelaci√≥n de los datos."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los tres elementos principales de una m√°quina de proceso?",
          "options": [
            "Hardware, software y usuario",
            "Entrada, unidad de proceso y salida",
            "Datos, algoritmos y resultados",
            "Compilador, int√©rprete y ejecutor"
          ],
          "correctAnswer": 1,
          "explanation": "El documento establece que una m√°quina de proceso tiene tres elementos: entrada (elementos que se introducen), unidad de proceso (donde se realiza el procesamiento) y salida (resultado del procesamiento)."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica diferencia al lenguaje m√°quina de los lenguajes de alto nivel?",
          "options": [
            "El lenguaje m√°quina es m√°s r√°pido",
            "El lenguaje m√°quina est√° compuesto por 0s y 1s y es directamente entendible por el procesador",
            "El lenguaje m√°quina es m√°s f√°cil de programar",
            "El lenguaje m√°quina no necesita compilaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "El documento explica que el lenguaje m√°quina est√° compuesto por instrucciones basadas en 0s y 1s que son directamente entendibles por el procesador."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre compiladores e int√©rpretes?",
          "options": [
            "Los compiladores son m√°s lentos que los int√©rpretes",
            "Los compiladores traducen completamente el programa antes de ejecutarlo, los int√©rpretes ejecutan cada instrucci√≥n seg√∫n la van traduciendo",
            "Los int√©rpretes son para lenguajes de alto nivel",
            "No hay diferencia significativa entre ambos"
          ],
          "correctAnswer": 1,
          "explanation": "Los compiladores traducen el programa fuente completamente antes de ejecutarlo, mientras que los int√©rpretes ejecutan cada instrucci√≥n seg√∫n las van traduciendo."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las dos caracter√≠sticas fundamentales que debe tener un algoritmo v√°lido?",
          "options": [
            "Rapidez y eficiencia",
            "Finitud y determinismo",
            "Simplicidad y claridad",
            "Portabilidad y reutilizaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "El documento destaca que las dos caracter√≠sticas fundamentales de un algoritmo son la finitud (debe tener un n√∫mero finito de pasos) y el determinismo (debe producir el mismo resultado para las mismas entradas)."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øQu√© representa la complejidad O(n) en los algoritmos?",
          "options": [
            "El n√∫mero de l√≠neas de c√≥digo",
            "La dificultad de programaci√≥n",
            "La eficiencia del algoritmo representada como una funci√≥n que depende del tama√±o 'n'",
            "El tiempo de desarrollo del algoritmo"
          ],
          "correctAnswer": 2,
          "explanation": "La eficiencia se representa como una funci√≥n que depende de un par√°metro llamado tama√±o 'n', y la complejidad de un algoritmo se llama orden O(n)."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øQu√© es un programa inform√°tico seg√∫n el documento?",
          "options": [
            "Solo el c√≥digo fuente escrito por el programador",
            "Tanto los datos como la secuencia de acciones para realizar el procesamiento deseado",
            "√önicamente las instrucciones que ejecuta el procesador",
            "El resultado final que obtiene el usuario"
          ],
          "correctAnswer": 1,
          "explanation": "El documento define programa inform√°tico como tanto los datos como la secuencia de acciones que hay que llevar a cabo para realizar el procesamiento deseado."
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øEn qu√© se diferencia un lenguaje ensamblador del lenguaje m√°quina?",
          "options": [
            "El ensamblador usa comandos de tres letras como SUB en lugar de 0s y 1s",
            "El ensamblador es un lenguaje de alto nivel",
            "El ensamblador no necesita traducci√≥n",
            "No hay diferencia, son lo mismo"
          ],
          "correctAnswer": 0,
          "explanation": "El lenguaje ensamblador utiliza comandos, normalmente de longitud tres como SUB para hacer restas, simplificando la complejidad del lenguaje m√°quina que usa 0s y 1s."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre eficacia y eficiencia en programaci√≥n?",
          "options": [
            "Eficacia es velocidad, eficiencia es precisi√≥n",
            "Eficacia es que el programa funcione, eficiencia es que funcione bien usando menos recursos",
            "Son sin√≥nimos en programaci√≥n",
            "Eficacia es para algoritmos, eficiencia para programas"
          ],
          "correctAnswer": 1,
          "explanation": "Eficacia implica que el programa funcione y cumpla los requisitos, mientras que eficiencia se refiere a realizar el trabajo r√°pidamente y utilizando la menor cantidad posible de recursos."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las fases del ciclo de vida del software mencionadas en el documento?",
          "options": [
            "An√°lisis, especificaci√≥n, dise√±o, implementaci√≥n, pruebas y mantenimiento",
            "Planificaci√≥n, desarrollo, testing y deployment",
            "Dise√±o, codificaci√≥n, compilaci√≥n y ejecuci√≥n",
            "Requisitos, arquitectura, desarrollo y mantenimiento"
          ],
          "correctAnswer": 0,
          "explanation": "El documento lista las fases como: an√°lisis (¬øqu√©?), especificaci√≥n, dise√±o (¬øc√≥mo?), implementaci√≥n, pruebas y mantenimiento."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øQu√© ventaja principal ofrecen los lenguajes de programaci√≥n de alto nivel?",
          "options": [
            "Son m√°s r√°pidos de ejecutar",
            "Su similitud con el lenguaje natural humano, normalmente el ingl√©s",
            "No necesitan ser traducidos",
            "Ocupan menos memoria"
          ],
          "correctAnswer": 1,
          "explanation": "Una de las ventajas de los lenguajes de programaci√≥n de alto nivel es su similitud con el lenguaje natural humano, normalmente con el ingl√©s."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øQu√© son los lenguajes imperativos o procedimentales?",
          "options": [
            "Lenguajes que describen el resultado deseado sin especificar los pasos",
            "Lenguajes que se centran en c√≥mo se debe realizar una tarea, detallando los pasos exactos",
            "Lenguajes que solo usan funciones matem√°ticas",
            "Lenguajes de bajo nivel √∫nicamente"
          ],
          "correctAnswer": 1,
          "explanation": "Los lenguajes imperativos se centran en c√≥mo se debe realizar una tarea, detallando los pasos exactos que el programa debe seguir para alcanzar un resultado."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© diferencia hay entre sintaxis y sem√°ntica en programaci√≥n?",
          "options": [
            "Sintaxis es el significado, sem√°ntica son las reglas",
            "Sintaxis son las reglas de escritura, sem√°ntica es el significado del c√≥digo",
            "Son conceptos id√©nticos",
            "Sintaxis es para compiladores, sem√°ntica para int√©rpretes"
          ],
          "correctAnswer": 1,
          "explanation": "La sintaxis se refiere a las reglas y estructuras gramaticales para escribir instrucciones, mientras la sem√°ntica alude al significado o interpretaci√≥n del c√≥digo escrito."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la estructura b√°sica de un programa seg√∫n el documento?",
          "options": [
            "Inicio, desarrollo y fin",
            "Entrada, procesamiento y salida de informaci√≥n",
            "Variables, funciones y clases",
            "Compilaci√≥n, enlazado y ejecuci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Todo programa sigue t√≠picamente un modelo b√°sico de entrada, procesamiento y salida de informaci√≥n, donde acepta datos de entrada y los procesa mediante algoritmos."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica NO es propia de un algoritmo v√°lido?",
          "options": [
            "Debe ser preciso e indicar el orden de realizaci√≥n",
            "Ha de estar definido",
            "Debe ser infinito para cubrir todos los casos",
            "Es independiente del lenguaje de programaci√≥n"
          ],
          "correctAnswer": 2,
          "explanation": "Un algoritmo debe ser finito, es decir, debe tener un n√∫mero finito de pasos. La opci√≥n de ser infinito contradice una caracter√≠stica fundamental de los algoritmos."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øQu√© ventajas tiene el pseudoc√≥digo frente a los diagramas de flujo?",
          "options": [
            "Es m√°s r√°pido de ejecutar",
            "Ocupa menos espacio, permite representar operaciones complejas f√°cilmente y es f√°cil convertir a c√≥digo",
            "Solo funciona con lenguajes espec√≠ficos",
            "No tiene ventajas significativas"
          ],
          "correctAnswer": 1,
          "explanation": "El documento menciona que el pseudoc√≥digo ocupa menos espacio en papel, permite representar operaciones repetitivas complejas f√°cilmente y es muy f√°cil pasar de pseudoc√≥digo a un programa."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øQu√© porcentaje del ciclo de vida del software corresponde al mantenimiento?",
          "options": [
            "20%",
            "50%",
            "80%",
            "100%"
          ],
          "correctAnswer": 2,
          "explanation": "El documento establece que la etapa de mantenimiento corresponde al 80% del ciclo de vida del software y va desde la obtenci√≥n de una herramienta operativa hasta la retirada del programa."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las herramientas b√°sicas necesarias para desarrollar software?",
          "options": [
            "Solo un IDE moderno",
            "Editor de texto plano, compilador y l√≠nea de comandos",
            "√önicamente un navegador web",
            "Solo el sistema operativo"
          ],
          "correctAnswer": 1,
          "explanation": "El documento menciona que las herramientas necesarias para desarrollar software son b√°sicamente tres: editor de texto plano, compilador y l√≠nea de comandos."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øQu√© es un semialgoritmo seg√∫n el documento?",
          "options": [
            "Un algoritmo que funciona solo la mitad del tiempo",
            "Un algoritmo incompleto en desarrollo",
            "Soluciones parciales que pueden no satisfacer finitud y determinismo",
            "Un algoritmo que solo resuelve la mitad del problema"
          ],
          "correctAnswer": 2,
          "explanation": "Los semialgoritmos son soluciones parciales que pueden no satisfacer las dos caracter√≠sticas fundamentales de finitud y determinismo."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øQu√© funcionalidades importantes incorporan los IDE modernos para mejorar el desarrollo?",
          "options": [
            "Solo compilaci√≥n autom√°tica",
            "Autocompletado del c√≥digo fuente y resaltado de errores mediante precompilaci√≥n en tiempo real",
            "√önicamente depuraci√≥n de c√≥digo",
            "Solo gesti√≥n de archivos"
          ],
          "correctAnswer": 1,
          "explanation": "Los IDE actuales permiten el autocompletado del c√≥digo fuente y el resaltado de posibles errores mediante una precompilaci√≥n en tiempo real mientras se escribe el c√≥digo."
        }
      ]
    },
    {
      "name": "Elementos de un programa inform√°tico",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los dos grandes bloques dentro de un programa inform√°tico?",
          "options": [
            "Bloque de entrada y bloque de salida",
            "Bloque de declaraci√≥n y bloque de instrucciones",
            "Bloque de variables y bloque de constantes",
            "Bloque de datos y bloque de operadores"
          ],
          "correctAnswer": 1,
          "explanation": "El documento establece que se pueden definir dos grandes bloques: el bloque de declaraci√≥n (donde se definen todos los objetos que se utilizan) y el bloque de instrucciones (que define las operaciones a realizar)."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øQu√© diferencia principal existe entre variables y constantes?",
          "options": [
            "Las variables ocupan m√°s memoria que las constantes",
            "Las variables pueden cambiar su valor durante la ejecuci√≥n, las constantes no",
            "Las variables son de tipo num√©rico, las constantes de tipo texto",
            "No hay diferencia, son sin√≥nimos"
          ],
          "correctAnswer": 1,
          "explanation": "Seg√∫n el documento, las variables representan un espacio de memoria cuyo valor puede cambiar durante la ejecuci√≥n, mientras que las constantes son datos cuyo valor no cambiar√° a lo largo del programa."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øCu√°ntos bytes ocupa el tipo de dato 'int' en Java?",
          "options": [
            "1 byte",
            "2 bytes",
            "4 bytes",
            "8 bytes"
          ],
          "correctAnswer": 2,
          "explanation": "Seg√∫n la tabla del documento, el tipo 'int' ocupa 4 bytes en memoria y tiene un rango de [-2¬≥¬π, 2¬≥¬π - 1]."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre 'char' y 'String' en Java?",
          "options": [
            "Char almacena n√∫meros, String almacena letras",
            "Char representa un √∫nico car√°cter, String representa varios caracteres",
            "No hay diferencia, son equivalentes",
            "Char es para may√∫sculas, String para min√∫sculas"
          ],
          "correctAnswer": 1,
          "explanation": "El documento explica que char representa un √∫nico car√°cter (entre comillas simples), mientras que String representa varios caracteres juntos, es decir, una cadena de caracteres (entre comillas dobles)."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øQu√© valores puede tomar una variable de tipo boolean?",
          "options": [
            "0 y 1 √∫nicamente",
            "true y false √∫nicamente",
            "Cualquier n√∫mero entero",
            "Cualquier car√°cter"
          ],
          "correctAnswer": 1,
          "explanation": "Los datos de tipo booleano pueden representar √∫nicamente dos tipos de valores: verdadero (true) y falso (false), heredados del √°lgebra de Boole."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øQu√© operador se utiliza para obtener el resto de una divisi√≥n en Java?",
          "options": [
            "/",
            "*",
            "%",
            "++"
          ],
          "correctAnswer": 2,
          "explanation": "Seg√∫n la tabla de operaciones aritm√©ticas del documento, el operador '%' se utiliza para obtener el resto de una divisi√≥n."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el resultado de la operaci√≥n l√≥gica 'true && false'?",
          "options": [
            "true",
            "false",
            "0",
            "1"
          ],
          "correctAnswer": 1,
          "explanation": "Seg√∫n la tabla de verdad del operador AND (&&), cuando uno de los operandos es false, el resultado siempre es false."
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øQu√© significa el operador '==' en Java?",
          "options": [
            "Asignaci√≥n de valor",
            "Comparaci√≥n de igualdad",
            "Suma y asignaci√≥n",
            "Incremento"
          ],
          "correctAnswer": 1,
          "explanation": "El documento establece que '==' es el operador de comparaci√≥n para verificar si dos valores son iguales, diferente del operador de asignaci√≥n '='."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øQu√© es un casting impl√≠cito (Upper-casting)?",
          "options": [
            "Conversi√≥n que requiere ayuda del programador",
            "Conversi√≥n autom√°tica de un tipo menor a uno mayor sin p√©rdida de informaci√≥n",
            "Conversi√≥n que siempre produce errores",
            "Conversi√≥n entre tipos incompatibles"
          ],
          "correctAnswer": 1,
          "explanation": "El casting impl√≠cito es una conversi√≥n autom√°tica que se realiza sin ayuda del programador, convirtiendo un tipo menor a uno mayor sin p√©rdida de informaci√≥n, como convertir un entero a real."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre '++x' y 'x++' en Java?",
          "options": [
            "No hay diferencia, ambos incrementan x",
            "++x incrementa antes de evaluar la expresi√≥n, x++ incrementa despu√©s",
            "++x incrementa de 2 en 2, x++ de 1 en 1",
            "++x solo funciona con enteros, x++ con cualquier tipo"
          ],
          "correctAnswer": 1,
          "explanation": "Seg√∫n el documento, ++x (preincremento) incrementa la variable antes de evaluar la expresi√≥n, mientras que x++ (postincremento) incrementa despu√©s de evaluar la expresi√≥n."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øQu√© m√©todo se utiliza para leer un n√∫mero entero desde teclado usando Scanner?",
          "options": [
            "nextDouble()",
            "nextLine()",
            "nextInt()",
            "next()"
          ],
          "correctAnswer": 2,
          "explanation": "El documento especifica que 'lectura.nextInt()' se utiliza para leer un n√∫mero entero desde el teclado cuando se usa la clase Scanner."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los elementos comunes que tienen la mayor√≠a de los lenguajes de programaci√≥n?",
          "options": [
            "Solo variables y operadores",
            "Caracteres, datos, identificadores, expresiones, operadores, instrucciones y comentarios",
            "√önicamente tipos de datos primitivos",
            "Solo bloques de c√≥digo"
          ],
          "correctAnswer": 1,
          "explanation": "El documento enumera estos elementos comunes: caracteres, datos, identificadores, expresiones y operadores, instrucciones, y comentarios."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© palabra reservada se utiliza en Java para declarar una constante?",
          "options": [
            "const",
            "final",
            "static",
            "constant"
          ],
          "correctAnswer": 1,
          "explanation": "Seg√∫n el documento, se emplea la palabra reservada 'final' para declarar constante cualquier tipo de dato en Java."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øQu√© operador l√≥gico devuelve el valor contrario a la variable a la que se aplica?",
          "options": [
            "&&",
            "||",
            "!",
            "=="
          ],
          "correctAnswer": 2,
          "explanation": "El operador NOT (!) es monario y devuelve el valor contrario a la variable a la que se aplica, seg√∫n se explica en el documento."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el rango de valores para el tipo 'byte' en Java?",
          "options": [
            "[-256, 255]",
            "[-128, 127]",
            "[0, 255]",
            "[-32768, 32767]"
          ],
          "correctAnswer": 1,
          "explanation": "Seg√∫n la tabla del documento, el tipo 'byte' que ocupa 1 byte en memoria tiene un rango de [-128, 127]."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øQu√© m√©todo de System.out imprime un mensaje con salto de l√≠nea?",
          "options": [
            "print()",
            "println()",
            "printf()",
            "write()"
          ],
          "correctAnswer": 1,
          "explanation": "El documento especifica que 'System.out.println()' imprime mensaje con salto de l√≠nea, mientras que 'System.out.print()' lo hace sin salto de l√≠nea."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øQu√© significa API en el contexto de Java?",
          "options": [
            "Advanced Programming Interface",
            "Application Programming Interface",
            "Automated Program Integration",
            "Abstract Programming Implementation"
          ],
          "correctAnswer": 1,
          "explanation": "Aunque el documento no define expl√≠citamente la sigla, se refiere a la API de Java como la biblioteca que proporciona funciones y herramientas para el desarrollo de aplicaciones, siendo API el acr√≥nimo de Application Programming Interface."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la sintaxis correcta para el operador ternario en Java?",
          "options": [
            "if ? valor1 : valor2",
            "Expresi√≥nL√≥gica ? valor1 : valor2",
            "condici√≥n -> valor1 : valor2",
            "expresi√≥n == valor1 ? valor2"
          ],
          "correctAnswer": 1,
          "explanation": "El documento muestra que la sintaxis del operador ternario es 'Expresi√≥nL√≥gica/Relacional ? valor1: valor2;' donde se selecciona uno de los dos valores dependiendo del resultado de la expresi√≥n."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øCon qu√© delimitadores se definen los bloques de c√≥digo en Java?",
          "options": [
            "Par√©ntesis ( )",
            "Corchetes [ ]",
            "Llaves { }",
            "Comillas \" \""
          ],
          "correctAnswer": 2,
          "explanation": "El documento especifica que en Java, los limitadores de bloques de c√≥digo son las llaves ({ })."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øPara qu√© se utilizan principalmente los tipos de datos booleanos?",
          "options": [
            "Para realizar operaciones aritm√©ticas",
            "Para almacenar cadenas de texto",
            "Para evaluaci√≥n de expresiones l√≥gicas y tratamiento de condiciones",
            "Para representar n√∫meros decimales"
          ],
          "correctAnswer": 2,
          "explanation": "El documento establece que los tipos booleanos no se utilizan para realizar operaciones, sino que su utilidad est√° en la evaluaci√≥n de expresiones l√≥gicas para el tratamiento de condiciones y comparaciones."
        }
      ]
    },
    {
      "name": "Programaci√≥n Estructurada",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las tres estructuras b√°sicas de la programaci√≥n estructurada?",
          "options": [
            "Secuencial, alternativa e iterativa",
            "Entrada, proceso y salida",
            "Variables, funciones y objetos",
            "If, while y for"
          ],
          "correctAnswer": 0,
          "explanation": "Seg√∫n el teorema de estructura, un programa estructurado se expresa √∫nicamente mediante combinaciones de las tres estructuras b√°sicas: secuencial, alternativa e iterativa."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la principal ventaja de la programaci√≥n estructurada?",
          "options": [
            "Mayor velocidad de ejecuci√≥n",
            "Menor uso de memoria",
            "Mayor legibilidad y facilidad de mantenimiento",
            "Compatibilidad con todos los lenguajes"
          ],
          "correctAnswer": 2,
          "explanation": "La programaci√≥n estructurada hace que los programas sean m√°s legibles, f√°ciles de entender, depurar y modificar, reduciendo los costes de mantenimiento."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øQu√© estructura de selecci√≥n permite evaluar m√∫ltiples casos de manera m√°s legible?",
          "options": [
            "if simple",
            "if-else",
            "switch",
            "while"
          ],
          "correctAnswer": 2,
          "explanation": "La estructura switch permite evaluar m√∫ltiples casos de manera m√°s legible que m√∫ltiples if-else anidados, mejorando la comprensi√≥n del c√≥digo."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia principal entre while y do-while?",
          "options": [
            "while es m√°s r√°pido que do-while",
            "do-while eval√∫a la condici√≥n al final, garantizando al menos una ejecuci√≥n",
            "while permite m√°s iteraciones que do-while",
            "No hay diferencia significativa"
          ],
          "correctAnswer": 1,
          "explanation": "La estructura do-while eval√∫a la condici√≥n al final del bloque, garantizando que el c√≥digo se ejecute al menos una vez, mientras que while eval√∫a la condici√≥n al inicio."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øQu√© tipo de datos son m√°s ampliamente aceptados en las estructuras switch?",
          "options": [
            "Flotantes y doubles",
            "Strings y arrays",
            "Car√°cter y entero",
            "Booleanos √∫nicamente"
          ],
          "correctAnswer": 2,
          "explanation": "En las estructuras switch, los tipos de datos m√°s ampliamente aceptados son car√°cter o entero, aunque los lenguajes modernos permiten otros tipos."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el principal riesgo de las estructuras iterativas mal dise√±adas?",
          "options": [
            "P√©rdida de datos",
            "Bucle infinito",
            "Error de sintaxis",
            "Incompatibilidad de tipos"
          ],
          "correctAnswer": 1,
          "explanation": "El error m√°s frecuente en estructuras iterativas es olvidar establecer correctamente la condici√≥n de finalizaci√≥n, lo que puede resultar en un bucle infinito."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øQu√© operador permite crear una versi√≥n m√°s compacta del if-else?",
          "options": [
            "Operador l√≥gico AND",
            "Operador ternario",
            "Operador de asignaci√≥n",
            "Operador de comparaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "El operador ternario (? :) permite sustituir una estructura if-else simple por una expresi√≥n m√°s compacta: variable = condici√≥n ? valor1 : valor2"
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo es m√°s apropiado usar un bucle for?",
          "options": [
            "Cuando no sabemos cu√°ntas iteraciones necesitamos",
            "Cuando tenemos un n√∫mero conocido de iteraciones",
            "Cuando queremos ejecutar c√≥digo al menos una vez",
            "Cuando trabajamos con condiciones complejas"
          ],
          "correctAnswer": 1,
          "explanation": "El bucle for es m√°s apropiado cuando tenemos un n√∫mero conocido o determinado de iteraciones, como sumar los 100 primeros n√∫meros enteros."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øQu√© sentencia de salto se recomienda usar √∫nicamente en estructuras switch?",
          "options": [
            "continue",
            "return",
            "break",
            "goto"
          ],
          "correctAnswer": 2,
          "explanation": "La sentencia break se recomienda usar √∫nicamente en estructuras switch para terminar cada caso, ya que as√≠ lo requiere la sintaxis del lenguaje."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la principal desventaja de la programaci√≥n estructurada?",
          "options": [
            "Mayor complejidad de c√≥digo",
            "Menor rendimiento",
            "Se obtiene un √∫nico bloque de programa que puede ser dif√≠cil de mantener si crece",
            "Incompatibilidad con lenguajes modernos"
          ],
          "correctAnswer": 2,
          "explanation": "La principal desventaja de la programaci√≥n estructurada es que se obtiene un √∫nico bloque de programa, el cual puede ser dif√≠cil de mantener si crece."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øQu√© elementos son necesarios para definir una estructura iterativa?",
          "options": [
            "Solo el cuerpo de la iteraci√≥n",
            "Cuerpo de iteraci√≥n, n√∫mero de repeticiones y condici√≥n de finalizaci√≥n",
            "Variables de entrada y salida",
            "√önicamente la condici√≥n de finalizaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Para definir una estructura iterativa se necesitan tres elementos: el cuerpo de la iteraci√≥n, el n√∫mero de repeticiones y la condici√≥n de finalizaci√≥n."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo es m√°s apropiado usar un bucle while?",
          "options": [
            "Cuando conocemos exactamente el n√∫mero de iteraciones",
            "Cuando el n√∫mero de iteraciones es desconocido y depende de una condici√≥n",
            "Cuando queremos ejecutar c√≥digo al menos una vez",
            "Nunca, es mejor usar for"
          ],
          "correctAnswer": 1,
          "explanation": "El bucle while es apropiado cuando el n√∫mero de iteraciones es desconocido porque depende de una condici√≥n, como solicitar n√∫meros hasta que sumen un valor determinado."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© permite la anidaci√≥n de estructuras de selecci√≥n?",
          "options": [
            "Ejecutar c√≥digo m√°s r√°pido",
            "Tratar m√∫ltiples condiciones de manera lineal",
            "Reducir el uso de memoria",
            "Eliminar la necesidad de variables"
          ],
          "correctAnswer": 1,
          "explanation": "La anidaci√≥n de estructuras de selecci√≥n permite tratar m√∫ltiples condiciones de manera lineal, estableciendo diferentes flujos seg√∫n se cumplan o no las condiciones."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la funci√≥n de la sentencia continue en un bucle?",
          "options": [
            "Terminar el bucle completamente",
            "Hacer que el bucle pase a la siguiente vuelta directamente",
            "Pausar la ejecuci√≥n",
            "Reiniciar el contador del bucle"
          ],
          "correctAnswer": 1,
          "explanation": "La sentencia continue hace que el bucle pase a la siguiente vuelta directamente, aumentando su contador y saltando el resto del c√≥digo en la iteraci√≥n actual."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica tienen todos los bucles (while, do-while, for)?",
          "options": [
            "Tienen la misma sintaxis",
            "Son equivalentes entre ellos",
            "Ejecutan a la misma velocidad",
            "Usan la misma cantidad de memoria"
          ],
          "correctAnswer": 1,
          "explanation": "Los bucles son equivalentes entre ellos, lo que significa que cualquier ejercicio que contenga bucles puede realizarse con while, do-while o for, aunque con algunos cambios."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo es m√°s apropiado usar do-while?",
          "options": [
            "Cuando conocemos el n√∫mero exacto de iteraciones",
            "Cuando la condici√≥n es muy compleja",
            "Cuando se tiene que ejecutar el c√≥digo al menos una vez",
            "Cuando queremos la m√°xima eficiencia"
          ],
          "correctAnswer": 2,
          "explanation": "Do-while es apropiado cuando se tiene que ejecutar el c√≥digo al menos una vez, como solicitar n√∫meros al usuario hasta que introduzca el 0."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øQu√© desarrollaron Dijkstra y otros autores a finales de los a√±os sesenta?",
          "options": [
            "Los primeros compiladores",
            "Los principios de la programaci√≥n estructurada",
            "Los lenguajes de alto nivel",
            "Las bases de datos relacionales"
          ],
          "correctAnswer": 1,
          "explanation": "A finales de los a√±os sesenta, Dijkstra junto con otros autores desarrollaron los principios de la programaci√≥n estructurada para solucionar los problemas de mantenimiento del c√≥digo."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øQu√© expresi√≥n debe devolver la condici√≥n en una estructura if?",
          "options": [
            "Un n√∫mero entero",
            "Una cadena de texto",
            "Un valor l√≥gico (verdadero o falso)",
            "Un valor decimal"
          ],
          "correctAnswer": 2,
          "explanation": "La expresi√≥n utilizada en la condici√≥n de una estructura if tiene que devolver un valor l√≥gico, es decir, verdadero o falso."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øQu√© componentes tiene la sintaxis del bucle for?",
          "options": [
            "Solo la condici√≥n del bucle",
            "Inicializaci√≥n, condici√≥n del bucle y paso",
            "Variables de entrada y salida",
            "√önicamente el incremento"
          ],
          "correctAnswer": 1,
          "explanation": "La sintaxis del bucle for tiene tres componentes: inicializaci√≥n (valor inicial), condici√≥n del bucle (cu√°ndo parar) y paso (c√≥mo modificar la variable de control)."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øPor qu√© no se recomienda el uso de sentencias de salto como goto?",
          "options": [
            "Son muy lentas",
            "Provocan una mala estructuraci√≥n del c√≥digo y dificultan su depuraci√≥n",
            "No est√°n disponibles en lenguajes modernos",
            "Consumen mucha memoria"
          ],
          "correctAnswer": 1,
          "explanation": "Las sentencias de salto como goto provocan una mala estructuraci√≥n del c√≥digo fuente, incrementando su complejidad y dificultando el seguimiento del flujo del programa y su depuraci√≥n."
        },
        {
          "id": 21,
          "type": "multiple_choice",
          "question": "¬øQu√© permite hacer las instrucciones de selecci√≥n en el flujo de ejecuci√≥n?",
          "options": [
            "Acelerar la ejecuci√≥n del programa",
            "Romper el orden secuencial de ejecuci√≥n",
            "Reducir el uso de variables",
            "Eliminar errores de sintaxis"
          ],
          "correctAnswer": 1,
          "explanation": "Las instrucciones de selecci√≥n permiten romper el orden secuencial de ejecuci√≥n, haciendo posible que algunos fragmentos de c√≥digo no se ejecuten seg√∫n las condiciones."
        },
        {
          "id": 22,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el objetivo principal de las estructuras de selecci√≥n complejas como switch?",
          "options": [
            "Aumentar la velocidad de ejecuci√≥n",
            "Mejorar la comprensi√≥n y estructura general del c√≥digo fuente",
            "Reducir el n√∫mero de variables necesarias",
            "Eliminar la necesidad de comentarios"
          ],
          "correctAnswer": 1,
          "explanation": "El objetivo de las estructuras de selecci√≥n complejas como switch es mejorar la comprensi√≥n y estructura general del c√≥digo fuente, garantizando su legibilidad."
        },
        {
          "id": 23,
          "type": "multiple_choice",
          "question": "¬øQu√© problema resolv√≠a la programaci√≥n estructurada antes de los a√±os 60?",
          "options": [
            "La falta de velocidad en los programas",
            "La ausencia de interfaces gr√°ficas",
            "Los programas sin estructura que dificultaban el mantenimiento",
            "La incompatibilidad entre diferentes computadoras"
          ],
          "correctAnswer": 2,
          "explanation": "Antes de los a√±os 60, los programas consist√≠an en un conjunto de instrucciones sin estructura, lo que dificultaba enormemente su mantenimiento."
        },
        {
          "id": 24,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica debe tener un programa bien estructurado seg√∫n los principios establecidos?",
          "options": [
            "Debe ser lo m√°s corto posible",
            "Debe usar solo variables globales",
            "El c√≥digo debe ser entendible sin necesidad de informaci√≥n adicional",
            "Debe ejecutarse en cualquier sistema operativo"
          ],
          "correctAnswer": 2,
          "explanation": "Uno de los principios fundamentales es que el c√≥digo debe ser entendible sin necesidad de informaci√≥n adicional, facilitando su comprensi√≥n y mantenimiento."
        },
        {
          "id": 25,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la ventaja de poder desarrollar un programa por partes seg√∫n la programaci√≥n estructurada?",
          "options": [
            "Reduce el tiempo total de ejecuci√≥n",
            "Las diferentes partes pueden ser modificadas sin afectar al resto del programa",
            "Elimina la necesidad de pruebas",
            "Garantiza que no habr√° errores"
          ],
          "correctAnswer": 1,
          "explanation": "La programaci√≥n estructurada permite que las diferentes partes del programa puedan ser modificadas o cambiadas sin que esto afecte al resto del programa, facilitando el mantenimiento."
        }
      ]
    },
    {
      "name": "Programaci√≥n Modular",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øEn qu√© metodolog√≠a se basa la programaci√≥n modular?",
          "options": [
            "Divide y vencer√°s",
            "Cascada",
            "Espiral",
            "Prototipado"
          ],
          "correctAnswer": 0,
          "explanation": "La programaci√≥n modular est√° basada en la metodolog√≠a denominada 'divide y vencer√°s', es decir, en la divisi√≥n del programa en subprogramas."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la principal ventaja de la programaci√≥n modular?",
          "options": [
            "Mayor velocidad de ejecuci√≥n",
            "Cada m√≥dulo puede ser desarrollado de forma independiente",
            "Menor uso de memoria",
            "Compatibilidad con todos los sistemas operativos"
          ],
          "correctAnswer": 1,
          "explanation": "Una ventaja de la programaci√≥n modular es que cada m√≥dulo puede ser desarrollado de forma independiente, mediante equipos independientes y probado de manera independiente."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øQu√© tipo de dise√±o consiste en descomposiciones sucesivas del algoritmo inicial?",
          "options": [
            "Dise√±o ascendente (bottom-up)",
            "Dise√±o modular descendente (top-down)",
            "Dise√±o lateral",
            "Dise√±o circular"
          ],
          "correctAnswer": 1,
          "explanation": "Un dise√±o modular descendente (top-down) consiste en una serie de descomposiciones sucesivas del algoritmo inicial denominadas m√≥dulos."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia principal entre procedimientos y funciones?",
          "options": [
            "Los procedimientos son m√°s r√°pidos",
            "Los procedimientos no devuelven valor, las funciones s√≠",
            "Las funciones usan m√°s memoria",
            "No hay diferencia significativa"
          ],
          "correctAnswer": 1,
          "explanation": "En el caso de los procedimientos, no se devuelve ning√∫n valor; mientras que en el caso de las funciones, podemos devolver un valor determinado."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øQu√© tipo de variables solo existen en un √°mbito determinado del programa?",
          "options": [
            "Variables globales",
            "Variables locales",
            "Variables est√°ticas",
            "Variables din√°micas"
          ],
          "correctAnswer": 1,
          "explanation": "Las variables locales solo existen en un √°mbito determinado del programa, por ejemplo, en un subprograma o en un bloque de sentencias."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øPor qu√© se recomienda evitar el uso de variables globales?",
          "options": [
            "Ocupan m√°s memoria",
            "Son m√°s lentas",
            "Pueden causar efectos secundarios dif√≠ciles de rastrear",
            "No son compatibles con todos los lenguajes"
          ],
          "correctAnswer": 2,
          "explanation": "Las variables globales pueden causar problemas porque cualquier parte del programa puede cambiar su valor sin control, causando efectos secundarios dif√≠ciles de rastrear y localizar."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øQu√© sucede en el paso de par√°metros por valor?",
          "options": [
            "Se pasa la direcci√≥n de memoria de la variable",
            "Se pasa una copia del valor de la variable",
            "Se pasa una referencia al objeto",
            "Se modifica directamente la variable original"
          ],
          "correctAnswer": 1,
          "explanation": "En el paso de par√°metros por valor, la funci√≥n va a recibir una copia de los valores reales, por lo que las modificaciones no afectan a la variable original."
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øQu√© permite la sobrecarga de m√©todos?",
          "options": [
            "Usar el mismo nombre de funci√≥n con diferentes tipos de datos",
            "Ejecutar m√∫ltiples funciones simult√°neamente",
            "Optimizar el uso de memoria",
            "Acelerar la ejecuci√≥n del programa"
          ],
          "correctAnswer": 0,
          "explanation": "La sobrecarga de funciones nos permite definir funciones con el mismo nombre que puedan trabajar con diferentes tipos de datos."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øC√≥mo se denominan los subprogramas en los lenguajes orientados a objetos?",
          "options": [
            "Procedimientos",
            "Funciones",
            "M√©todos",
            "M√≥dulos"
          ],
          "correctAnswer": 2,
          "explanation": "En el caso de los lenguajes orientados a objetos, los subprogramas se denominan m√©todos."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øQu√© son los par√°metros formales?",
          "options": [
            "Los valores que se pasan durante la ejecuci√≥n",
            "Los par√°metros especificados en el prototipo de la funci√≥n",
            "Los par√°metros que se modifican dentro de la funci√≥n",
            "Los par√°metros de tipo primitivo"
          ],
          "correctAnswer": 1,
          "explanation": "Los par√°metros formales hacen referencia a aquellos par√°metros que est√°n especificados en el prototipo de la funci√≥n, donde se especifica el tipo de cada uno de los par√°metros."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una de las principales ventajas del dise√±o modular?",
          "options": [
            "Menor tiempo de compilaci√≥n",
            "Facilita el desarrollo de programas en equipo",
            "Requiere menos documentaci√≥n",
            "Elimina todos los errores del programa"
          ],
          "correctAnswer": 1,
          "explanation": "Una de las ventajas del dise√±o modular es que facilita el desarrollo de programas en equipo, permitiendo que diferentes equipos trabajen en m√≥dulos independientes."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øQu√© se denomina librer√≠a en programaci√≥n?",
          "options": [
            "Un tipo especial de variable",
            "El conjunto de funciones que nos ofrece un lenguaje de programaci√≥n",
            "Un m√©todo de compilaci√≥n",
            "Una estructura de datos compleja"
          ],
          "correctAnswer": 1,
          "explanation": "El conjunto de funciones que nos ofrece un lenguaje de programaci√≥n se denomina librer√≠a."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© problema resuelve principalmente la programaci√≥n modular?",
          "options": [
            "La lentitud de ejecuci√≥n",
            "La duplicaci√≥n de c√≥digo y escasa reutilizaci√≥n",
            "La incompatibilidad entre sistemas",
            "El exceso de documentaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "La programaci√≥n modular resuelve problemas como la duplicaci√≥n de c√≥digo y la escasa reutilizaci√≥n de c√≥digo que se presentan en proyectos complejos."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo se dice que un subprograma es interno?",
          "options": [
            "Cuando est√° escrito en el mismo lenguaje que el programa principal",
            "Cuando figura en el mismo archivo fuente que el principal",
            "Cuando no tiene par√°metros de entrada",
            "Cuando no devuelve ning√∫n valor"
          ],
          "correctAnswer": 1,
          "explanation": "Si el subprograma figura en el mismo archivo fuente que el principal, se le denomina interno."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica tienen las variables declaradas en un subprograma?",
          "options": [
            "Son siempre globales",
            "Son locales, no conoci√©ndose fuera de √©l",
            "Se comparten autom√°ticamente con otros subprogramas",
            "Ocupan m√°s memoria que las variables globales"
          ],
          "correctAnswer": 1,
          "explanation": "Las variables declaradas en un subprograma son locales, no conoci√©ndose fuera de √©l, correspondiendo cada una a √°reas de memoria diferentes."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øQu√© ocurre en el paso de par√°metros por referencia?",
          "options": [
            "Se crea una copia del valor",
            "Los cambios sobre la variable receptora afectan a la variable original",
            "Se ejecuta m√°s lentamente",
            "No se pueden pasar objetos"
          ],
          "correctAnswer": 1,
          "explanation": "En el paso de par√°metros por referencia, los cambios que realicemos sobre la variable receptora van a afectar al valor de la variable que se utilice en la llamada formal de la funci√≥n."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el objetivo principal de evitar dividir el software en demasiados m√≥dulos?",
          "options": [
            "Reducir el tiempo de compilaci√≥n",
            "Buscar un equilibrio entre el esfuerzo de desarrollo y mantenimiento de interfaces",
            "Ahorrar memoria",
            "Simplificar la documentaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Es necesario buscar un equilibrio entre ambos esfuerzos, ya que dividir en muchos m√≥dulos incrementa el esfuerzo necesario para desarrollar y mantener las interfaces de comunicaci√≥n."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øQu√© permite establecer la sobrecarga de operadores?",
          "options": [
            "Crear nuevos tipos de datos",
            "Definir operadores con un nombre similar a los del lenguaje",
            "Acelerar las operaciones matem√°ticas",
            "Eliminar la necesidad de funciones"
          ],
          "correctAnswer": 1,
          "explanation": "La sobrecarga de operadores permite al programador definir operadores con un nombre similar a los propuestos por el lenguaje de programaci√≥n."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øQu√© ventaja ofrece la reutilizaci√≥n de m√≥dulos?",
          "options": [
            "Mayor velocidad de ejecuci√≥n",
            "Reducci√≥n del tiempo de desarrollo",
            "Menor uso de memoria",
            "Mejor interfaz de usuario"
          ],
          "correctAnswer": 1,
          "explanation": "La reutilizaci√≥n de m√≥dulos permite reducir el tiempo de desarrollo, ya que componentes ya desarrollados y probados pueden ser utilizados en nuevos proyectos."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una caracter√≠stica importante de un programa principal en programaci√≥n modular?",
          "options": [
            "Contiene todo el c√≥digo del programa",
            "Describe la soluci√≥n completa y consta principalmente de llamadas a subprogramas",
            "No puede llamar a otros subprogramas",
            "Siempre es el m√°s largo del programa"
          ],
          "correctAnswer": 1,
          "explanation": "Un programa principal describe la soluci√≥n completa del problema y consta, principalmente, de llamadas a subprogramas, conteniendo pocas l√≠neas donde se ven claramente los diferentes pasos del proceso."
        },
        {
          "id": 21,
          "type": "multiple_choice",
          "question": "¬øQu√© tipos de funciones se incluyen t√≠picamente en las librer√≠as de los lenguajes de programaci√≥n?",
          "options": [
            "Solo funciones matem√°ticas",
            "Funciones car√°cter, num√©ricas y aleatorias",
            "Solo funciones de entrada y salida",
            "√önicamente funciones definidas por el usuario"
          ],
          "correctAnswer": 1,
          "explanation": "Las librer√≠as incluyen funciones car√°cter (para trabajar con caracteres), funciones num√©ricas (para operaciones matem√°ticas) y funciones aleatorias (para n√∫meros pseudoaleatorios)."
        },
        {
          "id": 22,
          "type": "multiple_choice",
          "question": "¬øQu√© significa que un programa tenga una estructura de 'caja negra'?",
          "options": [
            "Que est√° compilado",
            "Que al facilitarle valores de entrada, devuelve valores de salida en funci√≥n de estos",
            "Que no se puede modificar",
            "Que est√° encriptado"
          ],
          "correctAnswer": 1,
          "explanation": "Cada subprograma tendr√° una estructura de caja negra, de forma que al facilitarle unos valores de entrada, devolver√° unos valores de salida en funci√≥n de los valores de entrada."
        },
        {
          "id": 23,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la relaci√≥n entre las funciones en programaci√≥n y las matem√°ticas?",
          "options": [
            "No tienen relaci√≥n",
            "Las funciones en programaci√≥n son exactamente iguales a las matem√°ticas",
            "Ambas permiten generar un resultado a partir de valores de entrada",
            "Solo se usan para operaciones num√©ricas"
          ],
          "correctAnswer": 2,
          "explanation": "Una funci√≥n permite, a partir de los valores de entrada, generar un resultado, siendo equivalente a una funci√≥n matem√°tica, pero la funci√≥n en programaci√≥n debe ser especificada paso a paso mediante un algoritmo."
        },
        {
          "id": 24,
          "type": "multiple_choice",
          "question": "¬øQu√© se debe considerar al definir par√°metros reales en una funci√≥n?",
          "options": [
            "Solo el nombre de los par√°metros",
            "Que coincidan en tipo y orden con los par√°metros formales",
            "Solo el n√∫mero de par√°metros",
            "√önicamente el tipo de retorno"
          ],
          "correctAnswer": 1,
          "explanation": "Los par√°metros reales deben coincidir en tipo y orden con los par√°metros especificados en el prototipo de la funci√≥n (par√°metros formales)."
        },
        {
          "id": 25,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una ventaja clave de utilizar buenas pr√°cticas como la programaci√≥n modular?",
          "options": [
            "Elimina completamente los errores",
            "Garantiza un cierto nivel de reutilizaci√≥n del c√≥digo y facilita el mantenimiento",
            "Reduce el tama√±o del c√≥digo fuente",
            "Acelera la velocidad de ejecuci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Utilizando buenas pr√°cticas como la programaci√≥n modular, podemos garantizar un cierto nivel de reutilizaci√≥n del c√≥digo que permite centralizar la l√≥gica y facilita el mantenimiento y la ampliaci√≥n del sistema."
        }
      ]
    }
  ]
}
