{
  "id": "programacion",
  "title": "Programaci√≥n",
  "description": "Cuestionario sobre los fundamentos de la programaci√≥n, elementos de un programa inform√°tico y programaci√≥n estructurada.",
  "icon": "üë©üèª‚Äçüíª",
  "items": [
    {
      "kind": "lesson",
      "name": "Fundamentos de Programaci√≥n",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia principal entre datos e informaci√≥n?",
          "options": [
            "Los datos son digitales y la informaci√≥n es anal√≥gica",
            "Los datos tienen significado puntual, la informaci√≥n resulta del procesamiento e interrelaci√≥n de datos",
            "Los datos son n√∫meros y la informaci√≥n son palabras",
            "No hay diferencia, son sin√≥nimos"
          ],
          "correctAnswer": 1,
          "explanation": "Los datos tienen un significado puntual mientras que la informaci√≥n resulta del procesamiento, interpretaci√≥n e interrelaci√≥n de los datos."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los tres elementos principales de una m√°quina de proceso?",
          "options": [
            "Hardware, software y usuario",
            "Entrada, unidad de proceso y salida",
            "Datos, algoritmos y resultados",
            "Compilador, int√©rprete y ejecutor"
          ],
          "correctAnswer": 1,
          "explanation": "Una m√°quina de proceso tiene tres elementos: entrada (elementos que se introducen), unidad de proceso (donde se realiza el procesamiento) y salida (resultado del procesamiento)."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica diferencia al lenguaje m√°quina de los lenguajes de alto nivel?",
          "options": [
            "El lenguaje m√°quina es m√°s r√°pido",
            "El lenguaje m√°quina est√° compuesto por 0s y 1s y es directamente entendible por el procesador",
            "El lenguaje m√°quina es m√°s f√°cil de programar",
            "El lenguaje m√°quina no necesita compilaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "El lenguaje m√°quina est√° compuesto por instrucciones basadas en 0s y 1s que son directamente entendibles por el procesador."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre compiladores e int√©rpretes?",
          "options": [
            "Los compiladores son m√°s lentos que los int√©rpretes",
            "Los compiladores traducen completamente el programa antes de ejecutarlo, los int√©rpretes ejecutan cada instrucci√≥n seg√∫n la van traduciendo",
            "Los int√©rpretes son para lenguajes de alto nivel",
            "No hay diferencia significativa entre ambos"
          ],
          "correctAnswer": 1,
          "explanation": "Los compiladores traducen el programa fuente completamente antes de ejecutarlo, mientras que los int√©rpretes ejecutan cada instrucci√≥n seg√∫n las van traduciendo."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las dos caracter√≠sticas fundamentales que debe tener un algoritmo v√°lido?",
          "options": [
            "Rapidez y eficiencia",
            "Finitud y determinismo",
            "Simplicidad y claridad",
            "Portabilidad y reutilizaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Las dos caracter√≠sticas fundamentales de un algoritmo son la finitud (debe tener un n√∫mero finito de pasos) y el determinismo (debe producir el mismo resultado para las mismas entradas)."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øQu√© representa la complejidad O(n) en los algoritmos?",
          "options": [
            "El n√∫mero de l√≠neas de c√≥digo",
            "La dificultad de programaci√≥n",
            "La eficiencia del algoritmo representada como una funci√≥n que depende del tama√±o 'n'",
            "El tiempo de desarrollo del algoritmo"
          ],
          "correctAnswer": 2,
          "explanation": "La eficiencia se representa como una funci√≥n que depende de un par√°metro llamado tama√±o 'n', y la complejidad de un algoritmo se llama orden O(n)."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øQu√© es un programa inform√°tico?",
          "options": [
            "Solo el c√≥digo fuente escrito por el programador",
            "Tanto los datos como la secuencia de acciones para realizar el procesamiento deseado",
            "√önicamente las instrucciones que ejecuta el procesador",
            "El resultado final que obtiene el usuario"
          ],
          "correctAnswer": 1,
          "explanation": "Un programa inform√°tico como tanto los datos como la secuencia de acciones que hay que llevar a cabo para realizar el procesamiento deseado."
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øEn qu√© se diferencia un lenguaje ensamblador del lenguaje m√°quina?",
          "options": [
            "El ensamblador usa comandos de tres letras como SUB en lugar de 0s y 1s",
            "El ensamblador es un lenguaje de alto nivel",
            "El ensamblador no necesita traducci√≥n",
            "No hay diferencia, son lo mismo"
          ],
          "correctAnswer": 0,
          "explanation": "El lenguaje ensamblador utiliza comandos, normalmente de longitud tres como SUB para hacer restas, simplificando la complejidad del lenguaje m√°quina que usa 0s y 1s."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre eficacia y eficiencia en programaci√≥n?",
          "options": [
            "Eficacia es velocidad, eficiencia es precisi√≥n",
            "Eficacia es que el programa funcione, eficiencia es que funcione bien usando menos recursos",
            "Son sin√≥nimos en programaci√≥n",
            "Eficacia es para algoritmos, eficiencia para programas"
          ],
          "correctAnswer": 1,
          "explanation": "Eficacia implica que el programa funcione y cumpla los requisitos, mientras que eficiencia se refiere a realizar el trabajo r√°pidamente y utilizando la menor cantidad posible de recursos."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las fases del ciclo de vida del software?",
          "options": [
            "An√°lisis, especificaci√≥n, dise√±o, implementaci√≥n, pruebas y mantenimiento",
            "Planificaci√≥n, desarrollo, testing y deployment",
            "Dise√±o, codificaci√≥n, compilaci√≥n y ejecuci√≥n",
            "Requisitos, arquitectura, desarrollo y mantenimiento"
          ],
          "correctAnswer": 0,
          "explanation": "An√°lisis (¬øqu√©?), especificaci√≥n, dise√±o (¬øc√≥mo?), implementaci√≥n, pruebas y mantenimiento."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øQu√© ventaja principal ofrecen los lenguajes de programaci√≥n de alto nivel?",
          "options": [
            "Son m√°s r√°pidos de ejecutar",
            "Su similitud con el lenguaje natural humano, normalmente el ingl√©s",
            "No necesitan ser traducidos",
            "Ocupan menos memoria"
          ],
          "correctAnswer": 1,
          "explanation": "Una de las ventajas de los lenguajes de programaci√≥n de alto nivel es su similitud con el lenguaje natural humano, normalmente con el ingl√©s."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øQu√© son los lenguajes imperativos o procedimentales?",
          "options": [
            "Lenguajes que describen el resultado deseado sin especificar los pasos",
            "Lenguajes que se centran en c√≥mo se debe realizar una tarea, detallando los pasos exactos",
            "Lenguajes que solo usan funciones matem√°ticas",
            "Lenguajes de bajo nivel √∫nicamente"
          ],
          "correctAnswer": 1,
          "explanation": "Los lenguajes imperativos se centran en c√≥mo se debe realizar una tarea, detallando los pasos exactos que el programa debe seguir para alcanzar un resultado."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© diferencia hay entre sintaxis y sem√°ntica en programaci√≥n?",
          "options": [
            "Sintaxis es el significado, sem√°ntica son las reglas",
            "Sintaxis son las reglas de escritura, sem√°ntica es el significado del c√≥digo",
            "Son conceptos id√©nticos",
            "Sintaxis es para compiladores, sem√°ntica para int√©rpretes"
          ],
          "correctAnswer": 1,
          "explanation": "La sintaxis se refiere a las reglas y estructuras gramaticales para escribir instrucciones, mientras la sem√°ntica alude al significado o interpretaci√≥n del c√≥digo escrito."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la estructura b√°sica de un programa?",
          "options": [
            "Inicio, desarrollo y fin",
            "Entrada, procesamiento y salida de informaci√≥n",
            "Variables, funciones y clases",
            "Compilaci√≥n, enlazado y ejecuci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Todo programa sigue t√≠picamente un modelo b√°sico de entrada, procesamiento y salida de informaci√≥n, donde acepta datos de entrada y los procesa mediante algoritmos."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica NO es propia de un algoritmo v√°lido?",
          "options": [
            "Debe ser preciso e indicar el orden de realizaci√≥n",
            "Ha de estar definido",
            "Debe ser infinito para cubrir todos los casos",
            "Es independiente del lenguaje de programaci√≥n"
          ],
          "correctAnswer": 2,
          "explanation": "Un algoritmo debe ser finito, es decir, debe tener un n√∫mero finito de pasos. La opci√≥n de ser infinito contradice una caracter√≠stica fundamental de los algoritmos."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øQu√© ventajas tiene el pseudoc√≥digo frente a los diagramas de flujo?",
          "options": [
            "Es m√°s r√°pido de ejecutar",
            "Ocupa menos espacio, permite representar operaciones complejas f√°cilmente y es f√°cil convertir a c√≥digo",
            "Solo funciona con lenguajes espec√≠ficos",
            "No tiene ventajas significativas"
          ],
          "correctAnswer": 1,
          "explanation": "El pseudoc√≥digo ocupa menos espacio en papel, permite representar operaciones repetitivas complejas f√°cilmente y es muy f√°cil pasar de pseudoc√≥digo a un programa."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øQu√© porcentaje del ciclo de vida del software corresponde al mantenimiento?",
          "options": [
            "20%",
            "50%",
            "80%",
            "100%"
          ],
          "correctAnswer": 2,
          "explanation": "La etapa de mantenimiento corresponde al 80% del ciclo de vida del software y va desde la obtenci√≥n de una herramienta operativa hasta la retirada del programa."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las herramientas b√°sicas necesarias para desarrollar software?",
          "options": [
            "Solo un IDE moderno",
            "Editor de texto plano, compilador y l√≠nea de comandos",
            "√önicamente un navegador web",
            "Solo el sistema operativo"
          ],
          "correctAnswer": 1,
          "explanation": "Las herramientas necesarias para desarrollar software son b√°sicamente tres: editor de texto plano, compilador y l√≠nea de comandos."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øQu√© es un semialgoritmo?",
          "options": [
            "Un algoritmo que funciona solo la mitad del tiempo",
            "Un algoritmo incompleto en desarrollo",
            "Soluciones parciales que pueden no satisfacer finitud y determinismo",
            "Un algoritmo que solo resuelve la mitad del problema"
          ],
          "correctAnswer": 2,
          "explanation": "Los semialgoritmos son soluciones parciales que pueden no satisfacer las dos caracter√≠sticas fundamentales de finitud y determinismo."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øQu√© funcionalidades importantes incorporan los IDE modernos para mejorar el desarrollo?",
          "options": [
            "Solo compilaci√≥n autom√°tica",
            "Autocompletado del c√≥digo fuente y resaltado de errores mediante precompilaci√≥n en tiempo real",
            "√önicamente depuraci√≥n de c√≥digo",
            "Solo gesti√≥n de archivos"
          ],
          "correctAnswer": 1,
          "explanation": "Los IDE actuales permiten el autocompletado del c√≥digo fuente y el resaltado de posibles errores mediante una precompilaci√≥n en tiempo real mientras se escribe el c√≥digo."
        }
      ]
    },
    {
      "kind": "lesson",
      "name": "Elementos de un programa inform√°tico",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los dos grandes bloques dentro de un programa inform√°tico?",
          "options": [
            "Bloque de entrada y bloque de salida",
            "Bloque de declaraci√≥n y bloque de instrucciones",
            "Bloque de variables y bloque de constantes",
            "Bloque de datos y bloque de operadores"
          ],
          "correctAnswer": 1,
          "explanation": "Se pueden definir dos grandes bloques: el bloque de declaraci√≥n (donde se definen todos los objetos que se utilizan) y el bloque de instrucciones (que define las operaciones a realizar)."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øQu√© diferencia principal existe entre variables y constantes?",
          "options": [
            "Las variables ocupan m√°s memoria que las constantes",
            "Las variables pueden cambiar su valor durante la ejecuci√≥n, las constantes no",
            "Las variables son de tipo num√©rico, las constantes de tipo texto",
            "No hay diferencia, son sin√≥nimos"
          ],
          "correctAnswer": 1,
          "explanation": "Las variables representan un espacio de memoria cuyo valor puede cambiar durante la ejecuci√≥n, mientras que las constantes son datos cuyo valor no cambiar√° a lo largo del programa."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øCu√°ntos bytes ocupa el tipo de dato 'int' en Java?",
          "options": [
            "1 byte",
            "2 bytes",
            "4 bytes",
            "8 bytes"
          ],
          "correctAnswer": 2,
          "explanation": "El tipo 'int' ocupa 4 bytes en memoria y tiene un rango de [-2¬≥¬π, 2¬≥¬π - 1]."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre 'char' y 'String' en Java?",
          "options": [
            "Char almacena n√∫meros, String almacena letras",
            "Char representa un √∫nico car√°cter, String representa varios caracteres",
            "No hay diferencia, son equivalentes",
            "Char es para may√∫sculas, String para min√∫sculas"
          ],
          "correctAnswer": 1,
          "explanation": "char representa un √∫nico car√°cter (entre comillas simples), mientras que String representa varios caracteres juntos, es decir, una cadena de caracteres (entre comillas dobles)."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øQu√© valores puede tomar una variable de tipo boolean?",
          "options": [
            "0 y 1 √∫nicamente",
            "true y false √∫nicamente",
            "Cualquier n√∫mero entero",
            "Cualquier car√°cter"
          ],
          "correctAnswer": 1,
          "explanation": "Los datos de tipo booleano pueden representar √∫nicamente dos tipos de valores: verdadero (true) y falso (false), heredados del √°lgebra de Boole."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øQu√© operador se utiliza para obtener el resto de una divisi√≥n en Java?",
          "options": [
            "/",
            "*",
            "%",
            "++"
          ],
          "correctAnswer": 2,
          "explanation": "El operador '%' se utiliza para obtener el resto de una divisi√≥n."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el resultado de la operaci√≥n l√≥gica 'true && false'?",
          "options": [
            "true",
            "false",
            "0",
            "1"
          ],
          "correctAnswer": 1,
          "explanation": "Seg√∫n la tabla de verdad del operador AND (&&), cuando uno de los operandos es false, el resultado siempre es false."
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øQu√© significa el operador '==' en Java?",
          "options": [
            "Asignaci√≥n de valor",
            "Comparaci√≥n de igualdad",
            "Suma y asignaci√≥n",
            "Incremento"
          ],
          "correctAnswer": 1,
          "explanation": "El operador '==' es el operador de comparaci√≥n para verificar si dos valores son iguales, diferente del operador de asignaci√≥n '='."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øQu√© es un casting impl√≠cito (Upper-casting)?",
          "options": [
            "Conversi√≥n que requiere ayuda del programador",
            "Conversi√≥n autom√°tica de un tipo menor a uno mayor sin p√©rdida de informaci√≥n",
            "Conversi√≥n que siempre produce errores",
            "Conversi√≥n entre tipos incompatibles"
          ],
          "correctAnswer": 1,
          "explanation": "El casting impl√≠cito es una conversi√≥n autom√°tica que se realiza sin ayuda del programador, convirtiendo un tipo menor a uno mayor sin p√©rdida de informaci√≥n, como convertir un entero a real."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia entre '++x' y 'x++' en Java?",
          "options": [
            "No hay diferencia, ambos incrementan x",
            "++x incrementa antes de evaluar la expresi√≥n, x++ incrementa despu√©s",
            "++x incrementa de 2 en 2, x++ de 1 en 1",
            "++x solo funciona con enteros, x++ con cualquier tipo"
          ],
          "correctAnswer": 1,
          "explanation": "++x (preincremento) incrementa la variable antes de evaluar la expresi√≥n, mientras que x++ (postincremento) incrementa despu√©s de evaluar la expresi√≥n."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øQu√© m√©todo se utiliza para leer un n√∫mero entero desde teclado usando Scanner?",
          "options": [
            "nextDouble()",
            "nextLine()",
            "nextInt()",
            "next()"
          ],
          "correctAnswer": 2,
          "explanation": "'nextInt()' se utiliza para leer un n√∫mero entero desde el teclado cuando se usa la clase Scanner."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los elementos comunes que tienen la mayor√≠a de los lenguajes de programaci√≥n?",
          "options": [
            "Solo variables y operadores",
            "Caracteres, datos, identificadores, expresiones, operadores, instrucciones y comentarios",
            "√önicamente tipos de datos primitivos",
            "Solo bloques de c√≥digo"
          ],
          "correctAnswer": 1,
          "explanation": "Caracteres, datos, identificadores, expresiones y operadores, instrucciones, y comentarios."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© palabra reservada se utiliza en Java para declarar una constante?",
          "options": [
            "const",
            "final",
            "static",
            "constant"
          ],
          "correctAnswer": 1,
          "explanation": "Se emplea la palabra reservada 'final' para declarar constante cualquier tipo de dato en Java."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øQu√© operador l√≥gico devuelve el valor contrario a la variable a la que se aplica?",
          "options": [
            "&&",
            "||",
            "!",
            "=="
          ],
          "correctAnswer": 2,
          "explanation": "El operador NOT (!) es monario y devuelve el valor contrario a la variable a la que se aplica."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el rango de valores para el tipo 'byte' en Java?",
          "options": [
            "[-256, 255]",
            "[-128, 127]",
            "[0, 255]",
            "[-32768, 32767]"
          ],
          "correctAnswer": 1,
          "explanation": "El tipo 'byte' que ocupa 1 byte en memoria tiene un rango de [-128, 127]."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øQu√© m√©todo de System.out imprime un mensaje con salto de l√≠nea?",
          "options": [
            "print()",
            "println()",
            "printf()",
            "write()"
          ],
          "correctAnswer": 1,
          "explanation": "'System.out.println()' imprime mensaje con salto de l√≠nea, mientras que 'System.out.print()' lo hace sin salto de l√≠nea."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øQu√© significa API en el contexto de Java?",
          "options": [
            "Advanced Programming Interface",
            "Application Programming Interface",
            "Automated Program Integration",
            "Abstract Programming Implementation"
          ],
          "correctAnswer": 1,
          "explanation": "La API de Java como la biblioteca que proporciona funciones y herramientas para el desarrollo de aplicaciones, siendo API el acr√≥nimo de Application Programming Interface."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la sintaxis correcta para el operador ternario en Java?",
          "options": [
            "if ? valor1 : valor2",
            "Expresi√≥nL√≥gica ? valor1 : valor2",
            "condici√≥n -> valor1 : valor2",
            "expresi√≥n == valor1 ? valor2"
          ],
          "correctAnswer": 1,
          "explanation": "La sintaxis del operador ternario es 'Expresi√≥nL√≥gica/Relacional ? valor1: valor2;' donde se selecciona uno de los dos valores dependiendo del resultado de la expresi√≥n."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øCon qu√© delimitadores se definen los bloques de c√≥digo en Java?",
          "options": [
            "Par√©ntesis ( )",
            "Corchetes [ ]",
            "Llaves { }",
            "Comillas \" \""
          ],
          "correctAnswer": 2,
          "explanation": "En Java los limitadores de bloques de c√≥digo son las llaves ({ })."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øPara qu√© se utilizan principalmente los tipos de datos booleanos?",
          "options": [
            "Para realizar operaciones aritm√©ticas",
            "Para almacenar cadenas de texto",
            "Para evaluaci√≥n de expresiones l√≥gicas y tratamiento de condiciones",
            "Para representar n√∫meros decimales"
          ],
          "correctAnswer": 2,
          "explanation": "Los tipos booleanos no se utilizan para realizar operaciones, sino que su utilidad est√° en la evaluaci√≥n de expresiones l√≥gicas para el tratamiento de condiciones y comparaciones."
        }
      ]
    },
    {
      "kind": "lesson",
      "name": "Programaci√≥n Estructurada",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øCu√°les son las tres estructuras b√°sicas de la programaci√≥n estructurada?",
          "options": [
            "Secuencial, alternativa e iterativa",
            "Entrada, proceso y salida",
            "Variables, funciones y objetos",
            "If, while y for"
          ],
          "correctAnswer": 0,
          "explanation": "Seg√∫n el teorema de estructura, un programa estructurado se expresa √∫nicamente mediante combinaciones de las tres estructuras b√°sicas: secuencial, alternativa e iterativa."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la principal ventaja de la programaci√≥n estructurada?",
          "options": [
            "Mayor velocidad de ejecuci√≥n",
            "Menor uso de memoria",
            "Mayor legibilidad y facilidad de mantenimiento",
            "Compatibilidad con todos los lenguajes"
          ],
          "correctAnswer": 2,
          "explanation": "La programaci√≥n estructurada hace que los programas sean m√°s legibles, f√°ciles de entender, depurar y modificar, reduciendo los costes de mantenimiento."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øQu√© estructura de selecci√≥n permite evaluar m√∫ltiples casos de manera m√°s legible?",
          "options": [
            "if simple",
            "if-else",
            "switch",
            "while"
          ],
          "correctAnswer": 2,
          "explanation": "La estructura switch permite evaluar m√∫ltiples casos de manera m√°s legible que m√∫ltiples if-else anidados, mejorando la comprensi√≥n del c√≥digo."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia principal entre while y do-while?",
          "options": [
            "while es m√°s r√°pido que do-while",
            "do-while eval√∫a la condici√≥n al final, garantizando al menos una ejecuci√≥n",
            "while permite m√°s iteraciones que do-while",
            "No hay diferencia significativa"
          ],
          "correctAnswer": 1,
          "explanation": "La estructura do-while eval√∫a la condici√≥n al final del bloque, garantizando que el c√≥digo se ejecute al menos una vez, mientras que while eval√∫a la condici√≥n al inicio."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øQu√© tipo de datos son m√°s ampliamente aceptados en las estructuras switch?",
          "options": [
            "Flotantes y doubles",
            "Strings y arrays",
            "Car√°cter y entero",
            "Booleanos √∫nicamente"
          ],
          "correctAnswer": 2,
          "explanation": "En las estructuras switch, los tipos de datos m√°s ampliamente aceptados son car√°cter o entero, aunque los lenguajes modernos permiten otros tipos."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el principal riesgo de las estructuras iterativas mal dise√±adas?",
          "options": [
            "P√©rdida de datos",
            "Bucle infinito",
            "Error de sintaxis",
            "Incompatibilidad de tipos"
          ],
          "correctAnswer": 1,
          "explanation": "El error m√°s frecuente en estructuras iterativas es olvidar establecer correctamente la condici√≥n de finalizaci√≥n, lo que puede resultar en un bucle infinito."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øQu√© operador permite crear una versi√≥n m√°s compacta del if-else?",
          "options": [
            "Operador l√≥gico AND",
            "Operador ternario",
            "Operador de asignaci√≥n",
            "Operador de comparaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "El operador ternario (? :) permite sustituir una estructura if-else simple por una expresi√≥n m√°s compacta: variable = condici√≥n ? valor1 : valor2"
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo es m√°s apropiado usar un bucle for?",
          "options": [
            "Cuando no sabemos cu√°ntas iteraciones necesitamos",
            "Cuando tenemos un n√∫mero conocido de iteraciones",
            "Cuando queremos ejecutar c√≥digo al menos una vez",
            "Cuando trabajamos con condiciones complejas"
          ],
          "correctAnswer": 1,
          "explanation": "El bucle for es m√°s apropiado cuando tenemos un n√∫mero conocido o determinado de iteraciones, como sumar los 100 primeros n√∫meros enteros."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øQu√© sentencia de salto se recomienda usar √∫nicamente en estructuras switch?",
          "options": [
            "continue",
            "return",
            "break",
            "goto"
          ],
          "correctAnswer": 2,
          "explanation": "La sentencia break se recomienda usar √∫nicamente en estructuras switch para terminar cada caso, ya que as√≠ lo requiere la sintaxis del lenguaje."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la principal desventaja de la programaci√≥n estructurada?",
          "options": [
            "Mayor complejidad de c√≥digo",
            "Menor rendimiento",
            "Se obtiene un √∫nico bloque de programa que puede ser dif√≠cil de mantener si crece",
            "Incompatibilidad con lenguajes modernos"
          ],
          "correctAnswer": 2,
          "explanation": "La principal desventaja de la programaci√≥n estructurada es que se obtiene un √∫nico bloque de programa, el cual puede ser dif√≠cil de mantener si crece."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øQu√© elementos son necesarios para definir una estructura iterativa?",
          "options": [
            "Solo el cuerpo de la iteraci√≥n",
            "Cuerpo de iteraci√≥n, n√∫mero de repeticiones y condici√≥n de finalizaci√≥n",
            "Variables de entrada y salida",
            "√önicamente la condici√≥n de finalizaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Para definir una estructura iterativa se necesitan tres elementos: el cuerpo de la iteraci√≥n, el n√∫mero de repeticiones y la condici√≥n de finalizaci√≥n."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo es m√°s apropiado usar un bucle while?",
          "options": [
            "Cuando conocemos exactamente el n√∫mero de iteraciones",
            "Cuando el n√∫mero de iteraciones es desconocido y depende de una condici√≥n",
            "Cuando queremos ejecutar c√≥digo al menos una vez",
            "Nunca, es mejor usar for"
          ],
          "correctAnswer": 1,
          "explanation": "El bucle while es apropiado cuando el n√∫mero de iteraciones es desconocido porque depende de una condici√≥n, como solicitar n√∫meros hasta que sumen un valor determinado."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© permite la anidaci√≥n de estructuras de selecci√≥n?",
          "options": [
            "Ejecutar c√≥digo m√°s r√°pido",
            "Tratar m√∫ltiples condiciones de manera lineal",
            "Reducir el uso de memoria",
            "Eliminar la necesidad de variables"
          ],
          "correctAnswer": 1,
          "explanation": "La anidaci√≥n de estructuras de selecci√≥n permite tratar m√∫ltiples condiciones de manera lineal, estableciendo diferentes flujos seg√∫n se cumplan o no las condiciones."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la funci√≥n de la sentencia continue en un bucle?",
          "options": [
            "Terminar el bucle completamente",
            "Hacer que el bucle pase a la siguiente vuelta directamente",
            "Pausar la ejecuci√≥n",
            "Reiniciar el contador del bucle"
          ],
          "correctAnswer": 1,
          "explanation": "La sentencia continue hace que el bucle pase a la siguiente vuelta directamente, aumentando su contador y saltando el resto del c√≥digo en la iteraci√≥n actual."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica tienen todos los bucles (while, do-while, for)?",
          "options": [
            "Tienen la misma sintaxis",
            "Son equivalentes entre ellos",
            "Ejecutan a la misma velocidad",
            "Usan la misma cantidad de memoria"
          ],
          "correctAnswer": 1,
          "explanation": "Los bucles son equivalentes entre ellos, lo que significa que cualquier ejercicio que contenga bucles puede realizarse con while, do-while o for, aunque con algunos cambios."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo es m√°s apropiado usar do-while?",
          "options": [
            "Cuando conocemos el n√∫mero exacto de iteraciones",
            "Cuando la condici√≥n es muy compleja",
            "Cuando se tiene que ejecutar el c√≥digo al menos una vez",
            "Cuando queremos la m√°xima eficiencia"
          ],
          "correctAnswer": 2,
          "explanation": "Do-while es apropiado cuando se tiene que ejecutar el c√≥digo al menos una vez, como solicitar n√∫meros al usuario hasta que introduzca el 0."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øQu√© desarrollaron Dijkstra y otros autores a finales de los a√±os sesenta?",
          "options": [
            "Los primeros compiladores",
            "Los principios de la programaci√≥n estructurada",
            "Los lenguajes de alto nivel",
            "Las bases de datos relacionales"
          ],
          "correctAnswer": 1,
          "explanation": "A finales de los a√±os sesenta, Dijkstra junto con otros autores desarrollaron los principios de la programaci√≥n estructurada para solucionar los problemas de mantenimiento del c√≥digo."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øQu√© expresi√≥n debe devolver la condici√≥n en una estructura if?",
          "options": [
            "Un n√∫mero entero",
            "Una cadena de texto",
            "Un valor l√≥gico (verdadero o falso)",
            "Un valor decimal"
          ],
          "correctAnswer": 2,
          "explanation": "La expresi√≥n utilizada en la condici√≥n de una estructura if tiene que devolver un valor l√≥gico, es decir, verdadero o falso."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øQu√© componentes tiene la sintaxis del bucle for?",
          "options": [
            "Solo la condici√≥n del bucle",
            "Inicializaci√≥n, condici√≥n del bucle y paso",
            "Variables de entrada y salida",
            "√önicamente el incremento"
          ],
          "correctAnswer": 1,
          "explanation": "La sintaxis del bucle for tiene tres componentes: inicializaci√≥n (valor inicial), condici√≥n del bucle (cu√°ndo parar) y paso (c√≥mo modificar la variable de control)."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øPor qu√© no se recomienda el uso de sentencias de salto como goto?",
          "options": [
            "Son muy lentas",
            "Provocan una mala estructuraci√≥n del c√≥digo y dificultan su depuraci√≥n",
            "No est√°n disponibles en lenguajes modernos",
            "Consumen mucha memoria"
          ],
          "correctAnswer": 1,
          "explanation": "Las sentencias de salto como goto provocan una mala estructuraci√≥n del c√≥digo fuente, incrementando su complejidad y dificultando el seguimiento del flujo del programa y su depuraci√≥n."
        },
        {
          "id": 21,
          "type": "multiple_choice",
          "question": "¬øQu√© permite hacer las instrucciones de selecci√≥n en el flujo de ejecuci√≥n?",
          "options": [
            "Acelerar la ejecuci√≥n del programa",
            "Romper el orden secuencial de ejecuci√≥n",
            "Reducir el uso de variables",
            "Eliminar errores de sintaxis"
          ],
          "correctAnswer": 1,
          "explanation": "Las instrucciones de selecci√≥n permiten romper el orden secuencial de ejecuci√≥n, haciendo posible que algunos fragmentos de c√≥digo no se ejecuten seg√∫n las condiciones."
        },
        {
          "id": 22,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el objetivo principal de las estructuras de selecci√≥n complejas como switch?",
          "options": [
            "Aumentar la velocidad de ejecuci√≥n",
            "Mejorar la comprensi√≥n y estructura general del c√≥digo fuente",
            "Reducir el n√∫mero de variables necesarias",
            "Eliminar la necesidad de comentarios"
          ],
          "correctAnswer": 1,
          "explanation": "El objetivo de las estructuras de selecci√≥n complejas como switch es mejorar la comprensi√≥n y estructura general del c√≥digo fuente, garantizando su legibilidad."
        },
        {
          "id": 23,
          "type": "multiple_choice",
          "question": "¬øQu√© problema resolv√≠a la programaci√≥n estructurada antes de los a√±os 60?",
          "options": [
            "La falta de velocidad en los programas",
            "La ausencia de interfaces gr√°ficas",
            "Los programas sin estructura que dificultaban el mantenimiento",
            "La incompatibilidad entre diferentes computadoras"
          ],
          "correctAnswer": 2,
          "explanation": "Antes de los a√±os 60, los programas consist√≠an en un conjunto de instrucciones sin estructura, lo que dificultaba enormemente su mantenimiento."
        },
        {
          "id": 24,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica debe tener un programa bien estructurado seg√∫n los principios establecidos?",
          "options": [
            "Debe ser lo m√°s corto posible",
            "Debe usar solo variables globales",
            "El c√≥digo debe ser entendible sin necesidad de informaci√≥n adicional",
            "Debe ejecutarse en cualquier sistema operativo"
          ],
          "correctAnswer": 2,
          "explanation": "Uno de los principios fundamentales es que el c√≥digo debe ser entendible sin necesidad de informaci√≥n adicional, facilitando su comprensi√≥n y mantenimiento."
        },
        {
          "id": 25,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la ventaja de poder desarrollar un programa por partes seg√∫n la programaci√≥n estructurada?",
          "options": [
            "Reduce el tiempo total de ejecuci√≥n",
            "Las diferentes partes pueden ser modificadas sin afectar al resto del programa",
            "Elimina la necesidad de pruebas",
            "Garantiza que no habr√° errores"
          ],
          "correctAnswer": 1,
          "explanation": "La programaci√≥n estructurada permite que las diferentes partes del programa puedan ser modificadas o cambiadas sin que esto afecte al resto del programa, facilitando el mantenimiento."
        }
      ]
    },
    {
      "kind": "lesson",
      "name": "Programaci√≥n Modular",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øEn qu√© metodolog√≠a se basa la programaci√≥n modular?",
          "options": [
            "Divide y vencer√°s",
            "Cascada",
            "Espiral",
            "Prototipado"
          ],
          "correctAnswer": 0,
          "explanation": "La programaci√≥n modular est√° basada en la metodolog√≠a denominada 'divide y vencer√°s', es decir, en la divisi√≥n del programa en subprogramas."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la principal ventaja de la programaci√≥n modular?",
          "options": [
            "Mayor velocidad de ejecuci√≥n",
            "Cada m√≥dulo puede ser desarrollado de forma independiente",
            "Menor uso de memoria",
            "Compatibilidad con todos los sistemas operativos"
          ],
          "correctAnswer": 1,
          "explanation": "Una ventaja de la programaci√≥n modular es que cada m√≥dulo puede ser desarrollado de forma independiente, mediante equipos independientes y probado de manera independiente."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øQu√© tipo de dise√±o consiste en descomposiciones sucesivas del algoritmo inicial?",
          "options": [
            "Dise√±o ascendente (bottom-up)",
            "Dise√±o modular descendente (top-down)",
            "Dise√±o lateral",
            "Dise√±o circular"
          ],
          "correctAnswer": 1,
          "explanation": "Un dise√±o modular descendente (top-down) consiste en una serie de descomposiciones sucesivas del algoritmo inicial denominadas m√≥dulos."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la diferencia principal entre procedimientos y funciones?",
          "options": [
            "Los procedimientos son m√°s r√°pidos",
            "Los procedimientos no devuelven valor, las funciones s√≠",
            "Las funciones usan m√°s memoria",
            "No hay diferencia significativa"
          ],
          "correctAnswer": 1,
          "explanation": "En el caso de los procedimientos, no se devuelve ning√∫n valor; mientras que en el caso de las funciones, podemos devolver un valor determinado."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øQu√© tipo de variables solo existen en un √°mbito determinado del programa?",
          "options": [
            "Variables globales",
            "Variables locales",
            "Variables est√°ticas",
            "Variables din√°micas"
          ],
          "correctAnswer": 1,
          "explanation": "Las variables locales solo existen en un √°mbito determinado del programa, por ejemplo, en un subprograma o en un bloque de sentencias."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øPor qu√© se recomienda evitar el uso de variables globales?",
          "options": [
            "Ocupan m√°s memoria",
            "Son m√°s lentas",
            "Pueden causar efectos secundarios dif√≠ciles de rastrear",
            "No son compatibles con todos los lenguajes"
          ],
          "correctAnswer": 2,
          "explanation": "Las variables globales pueden causar problemas porque cualquier parte del programa puede cambiar su valor sin control, causando efectos secundarios dif√≠ciles de rastrear y localizar."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øQu√© sucede en el paso de par√°metros por valor?",
          "options": [
            "Se pasa la direcci√≥n de memoria de la variable",
            "Se pasa una copia del valor de la variable",
            "Se pasa una referencia al objeto",
            "Se modifica directamente la variable original"
          ],
          "correctAnswer": 1,
          "explanation": "En el paso de par√°metros por valor, la funci√≥n va a recibir una copia de los valores reales, por lo que las modificaciones no afectan a la variable original."
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øQu√© permite la sobrecarga de m√©todos?",
          "options": [
            "Usar el mismo nombre de funci√≥n con diferentes tipos de datos",
            "Ejecutar m√∫ltiples funciones simult√°neamente",
            "Optimizar el uso de memoria",
            "Acelerar la ejecuci√≥n del programa"
          ],
          "correctAnswer": 0,
          "explanation": "La sobrecarga de funciones nos permite definir funciones con el mismo nombre que puedan trabajar con diferentes tipos de datos."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øC√≥mo se denominan los subprogramas en los lenguajes orientados a objetos?",
          "options": [
            "Procedimientos",
            "Funciones",
            "M√©todos",
            "M√≥dulos"
          ],
          "correctAnswer": 2,
          "explanation": "En el caso de los lenguajes orientados a objetos, los subprogramas se denominan m√©todos."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øQu√© son los par√°metros formales?",
          "options": [
            "Los valores que se pasan durante la ejecuci√≥n",
            "Los par√°metros especificados en el prototipo de la funci√≥n",
            "Los par√°metros que se modifican dentro de la funci√≥n",
            "Los par√°metros de tipo primitivo"
          ],
          "correctAnswer": 1,
          "explanation": "Los par√°metros formales hacen referencia a aquellos par√°metros que est√°n especificados en el prototipo de la funci√≥n, donde se especifica el tipo de cada uno de los par√°metros."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una de las principales ventajas del dise√±o modular?",
          "options": [
            "Menor tiempo de compilaci√≥n",
            "Facilita el desarrollo de programas en equipo",
            "Requiere menos documentaci√≥n",
            "Elimina todos los errores del programa"
          ],
          "correctAnswer": 1,
          "explanation": "Una de las ventajas del dise√±o modular es que facilita el desarrollo de programas en equipo, permitiendo que diferentes equipos trabajen en m√≥dulos independientes."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øQu√© se denomina librer√≠a en programaci√≥n?",
          "options": [
            "Un tipo especial de variable",
            "El conjunto de funciones que nos ofrece un lenguaje de programaci√≥n",
            "Un m√©todo de compilaci√≥n",
            "Una estructura de datos compleja"
          ],
          "correctAnswer": 1,
          "explanation": "El conjunto de funciones que nos ofrece un lenguaje de programaci√≥n se denomina librer√≠a."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© problema resuelve principalmente la programaci√≥n modular?",
          "options": [
            "La lentitud de ejecuci√≥n",
            "La duplicaci√≥n de c√≥digo y escasa reutilizaci√≥n",
            "La incompatibilidad entre sistemas",
            "El exceso de documentaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "La programaci√≥n modular resuelve problemas como la duplicaci√≥n de c√≥digo y la escasa reutilizaci√≥n de c√≥digo que se presentan en proyectos complejos."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øCu√°ndo se dice que un subprograma es interno?",
          "options": [
            "Cuando est√° escrito en el mismo lenguaje que el programa principal",
            "Cuando figura en el mismo archivo fuente que el principal",
            "Cuando no tiene par√°metros de entrada",
            "Cuando no devuelve ning√∫n valor"
          ],
          "correctAnswer": 1,
          "explanation": "Si el subprograma figura en el mismo archivo fuente que el principal, se le denomina interno."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øQu√© caracter√≠stica tienen las variables declaradas en un subprograma?",
          "options": [
            "Son siempre globales",
            "Son locales, no conoci√©ndose fuera de √©l",
            "Se comparten autom√°ticamente con otros subprogramas",
            "Ocupan m√°s memoria que las variables globales"
          ],
          "correctAnswer": 1,
          "explanation": "Las variables declaradas en un subprograma son locales, no conoci√©ndose fuera de √©l, correspondiendo cada una a √°reas de memoria diferentes."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øQu√© ocurre en el paso de par√°metros por referencia?",
          "options": [
            "Se crea una copia del valor",
            "Los cambios sobre la variable receptora afectan a la variable original",
            "Se ejecuta m√°s lentamente",
            "No se pueden pasar objetos"
          ],
          "correctAnswer": 1,
          "explanation": "En el paso de par√°metros por referencia, los cambios que realicemos sobre la variable receptora van a afectar al valor de la variable que se utilice en la llamada formal de la funci√≥n."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el objetivo principal de evitar dividir el software en demasiados m√≥dulos?",
          "options": [
            "Reducir el tiempo de compilaci√≥n",
            "Buscar un equilibrio entre el esfuerzo de desarrollo y mantenimiento de interfaces",
            "Ahorrar memoria",
            "Simplificar la documentaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Es necesario buscar un equilibrio entre ambos esfuerzos, ya que dividir en muchos m√≥dulos incrementa el esfuerzo necesario para desarrollar y mantener las interfaces de comunicaci√≥n."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "¬øQu√© permite establecer la sobrecarga de operadores?",
          "options": [
            "Crear nuevos tipos de datos",
            "Definir operadores con un nombre similar a los del lenguaje",
            "Acelerar las operaciones matem√°ticas",
            "Eliminar la necesidad de funciones"
          ],
          "correctAnswer": 1,
          "explanation": "La sobrecarga de operadores permite al programador definir operadores con un nombre similar a los propuestos por el lenguaje de programaci√≥n."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øQu√© ventaja ofrece la reutilizaci√≥n de m√≥dulos?",
          "options": [
            "Mayor velocidad de ejecuci√≥n",
            "Reducci√≥n del tiempo de desarrollo",
            "Menor uso de memoria",
            "Mejor interfaz de usuario"
          ],
          "correctAnswer": 1,
          "explanation": "La reutilizaci√≥n de m√≥dulos permite reducir el tiempo de desarrollo, ya que componentes ya desarrollados y probados pueden ser utilizados en nuevos proyectos."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una caracter√≠stica importante de un programa principal en programaci√≥n modular?",
          "options": [
            "Contiene todo el c√≥digo del programa",
            "Describe la soluci√≥n completa y consta principalmente de llamadas a subprogramas",
            "No puede llamar a otros subprogramas",
            "Siempre es el m√°s largo del programa"
          ],
          "correctAnswer": 1,
          "explanation": "Un programa principal describe la soluci√≥n completa del problema y consta, principalmente, de llamadas a subprogramas, conteniendo pocas l√≠neas donde se ven claramente los diferentes pasos del proceso."
        },
        {
          "id": 21,
          "type": "multiple_choice",
          "question": "¬øQu√© tipos de funciones se incluyen t√≠picamente en las librer√≠as de los lenguajes de programaci√≥n?",
          "options": [
            "Solo funciones matem√°ticas",
            "Funciones car√°cter, num√©ricas y aleatorias",
            "Solo funciones de entrada y salida",
            "√önicamente funciones definidas por el usuario"
          ],
          "correctAnswer": 1,
          "explanation": "Las librer√≠as incluyen funciones car√°cter (para trabajar con caracteres), funciones num√©ricas (para operaciones matem√°ticas) y funciones aleatorias (para n√∫meros pseudoaleatorios)."
        },
        {
          "id": 22,
          "type": "multiple_choice",
          "question": "¬øQu√© significa que un programa tenga una estructura de 'caja negra'?",
          "options": [
            "Que est√° compilado",
            "Que al facilitarle valores de entrada, devuelve valores de salida en funci√≥n de estos",
            "Que no se puede modificar",
            "Que est√° encriptado"
          ],
          "correctAnswer": 1,
          "explanation": "Cada subprograma tendr√° una estructura de caja negra, de forma que al facilitarle unos valores de entrada, devolver√° unos valores de salida en funci√≥n de los valores de entrada."
        },
        {
          "id": 23,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la relaci√≥n entre las funciones en programaci√≥n y las matem√°ticas?",
          "options": [
            "No tienen relaci√≥n",
            "Las funciones en programaci√≥n son exactamente iguales a las matem√°ticas",
            "Ambas permiten generar un resultado a partir de valores de entrada",
            "Solo se usan para operaciones num√©ricas"
          ],
          "correctAnswer": 2,
          "explanation": "Una funci√≥n permite, a partir de los valores de entrada, generar un resultado, siendo equivalente a una funci√≥n matem√°tica, pero la funci√≥n en programaci√≥n debe ser especificada paso a paso mediante un algoritmo."
        },
        {
          "id": 24,
          "type": "multiple_choice",
          "question": "¬øQu√© se debe considerar al definir par√°metros reales en una funci√≥n?",
          "options": [
            "Solo el nombre de los par√°metros",
            "Que coincidan en tipo y orden con los par√°metros formales",
            "Solo el n√∫mero de par√°metros",
            "√önicamente el tipo de retorno"
          ],
          "correctAnswer": 1,
          "explanation": "Los par√°metros reales deben coincidir en tipo y orden con los par√°metros especificados en el prototipo de la funci√≥n (par√°metros formales)."
        },
        {
          "id": 25,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una ventaja clave de utilizar buenas pr√°cticas como la programaci√≥n modular?",
          "options": [
            "Elimina completamente los errores",
            "Garantiza un cierto nivel de reutilizaci√≥n del c√≥digo y facilita el mantenimiento",
            "Reduce el tama√±o del c√≥digo fuente",
            "Acelera la velocidad de ejecuci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "Utilizando buenas pr√°cticas como la programaci√≥n modular, podemos garantizar un cierto nivel de reutilizaci√≥n del c√≥digo que permite centralizar la l√≥gica y facilita el mantenimiento y la ampliaci√≥n del sistema."
        }
      ]
    },
    {
      "kind": "lesson",
      "name": "Recursi√≥n en Programaci√≥n",
      "questions": [
        {
          "id": 1,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la definici√≥n formal de recursividad en programaci√≥n?",
          "options": [
            "La utilizaci√≥n de bucles for anidados para resolver problemas complejos",
            "La utilizaci√≥n de un concepto o proceso para la resoluci√≥n de problemas sobre s√≠ mismo mediante una versi√≥n m√°s sencilla",
            "El uso de m√∫ltiples funciones que se llaman secuencialmente",
            "La implementaci√≥n de algoritmos usando √∫nicamente estructuras condicionales"
          ],
          "correctAnswer": 1,
          "explanation": "La recursividad se define formalmente como la utilizaci√≥n de un concepto o proceso para la resoluci√≥n de problemas sobre s√≠ mismo mediante una versi√≥n m√°s sencilla, siendo un t√©rmino heredado de la matem√°tica."
        },
        {
          "id": 2,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los elementos fundamentales que debe tener toda soluci√≥n recursiva?",
          "options": [
            "Caso base y proceso de recursi√≥n",
            "Bucle principal y contador",
            "Variable global y funci√≥n local",
            "Array din√°mico y puntero"
          ],
          "correctAnswer": 0,
          "explanation": "Toda soluci√≥n recursiva debe tener un caso base (situaci√≥n de finalizaci√≥n) y un proceso de recursi√≥n (llamadas de la funci√≥n sobre s√≠ misma hasta llegar al caso base)."
        },
        {
          "id": 3,
          "type": "multiple_choice",
          "question": "¬øQu√© es el caso base en recursividad?",
          "options": [
            "El primer valor que se pasa a la funci√≥n",
            "La situaci√≥n de finalizaci√≥n de la recursividad donde se puede identificar un valor por defecto",
            "El n√∫mero m√°ximo de llamadas recursivas permitidas",
            "La condici√≥n inicial del problema"
          ],
          "correctAnswer": 1,
          "explanation": "El caso base es la situaci√≥n de finalizaci√≥n de la recursividad, donde se puede identificar un valor por defecto de una funci√≥n, evitando as√≠ llamadas infinitas."
        },
        {
          "id": 4,
          "type": "multiple_choice",
          "question": "¬øQu√© estructura de datos se utiliza internamente para manejar las llamadas recursivas?",
          "options": [
            "Cola (Queue)",
            "Lista enlazada",
            "Pila de llamadas (Stack)",
            "√Årbol binario"
          ],
          "correctAnswer": 2,
          "explanation": "Las llamadas recursivas se manejan mediante una pila de llamadas (stack), que almacena las estructuras intermedias necesarias para atender cada llamada."
        },
        {
          "id": 5,
          "type": "multiple_choice",
          "question": "¬øQu√© error se produce cuando se realizan demasiadas llamadas recursivas?",
          "options": [
            "Null pointer exception",
            "Desbordamiento de pila (stack overflow)",
            "Memory leak",
            "Array out of bounds"
          ],
          "correctAnswer": 1,
          "explanation": "Cuando se realizan muchas llamadas recursivas se puede producir un desbordamiento de pila (stack overflow), relacionado con los recursos limitados de memoria de la m√°quina."
        },
        {
          "id": 6,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la f√≥rmula matem√°tica correcta para el factorial?",
          "options": [
            "F(n) = n + F(n-1)",
            "F(n) = 1 si n = 0; n*F(n-1) si n > 0",
            "F(n) = F(n-1) + F(n-2)",
            "F(n) = n¬≤ * F(n-1)"
          ],
          "correctAnswer": 1,
          "explanation": "El factorial se define como F(n) = 1 si n = 0 (caso base), y F(n) = n*F(n-1) si n > 0 (caso recursivo)."
        },
        {
          "id": 7,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la definici√≥n matem√°tica correcta de la serie de Fibonacci?",
          "options": [
            "F(n) = n * F(n-1)",
            "F(n) = 0 si n = 0; 1 si n = 1; F(n-1) + F(n-2) si n >= 2",
            "F(n) = 2 * F(n-1)",
            "F(n) = F(n-1) * F(n-2)"
          ],
          "correctAnswer": 1,
          "explanation": "Fibonacci se define con dos casos base: F(0) = 0, F(1) = 1, y el caso recursivo F(n) = F(n-1) + F(n-2) para n >= 2."
        },
        {
          "id": 8,
          "type": "multiple_choice",
          "question": "¬øQu√© tipo de recursividad utiliza la funci√≥n de Fibonacci?",
          "options": [
            "Recursividad directa simple",
            "Recursividad indirecta",
            "Recursividad m√∫ltiple",
            "Recursividad en aumento"
          ],
          "correctAnswer": 2,
          "explanation": "Fibonacci utiliza recursividad m√∫ltiple porque en el caso general se realizan dos llamadas recursivas: F(n-1) + F(n-2)."
        },
        {
          "id": 9,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una ventaja principal de usar recursividad?",
          "options": [
            "Siempre es m√°s r√°pida que las soluciones iterativas",
            "Usa menos memoria que otras t√©cnicas",
            "Es una opci√≥n m√°s elegante de resoluci√≥n y en muchas ocasiones m√°s eficiente",
            "Nunca produce errores de ejecuci√≥n"
          ],
          "correctAnswer": 2,
          "explanation": "La recursividad es una opci√≥n m√°s elegante de resoluci√≥n y, en muchas ocasiones, m√°s eficiente, especialmente cuando empleamos el mismo problema con diferentes valores de entrada."
        },
        {
          "id": 10,
          "type": "multiple_choice",
          "question": "¬øPara qu√© tipo de estructuras de datos es especialmente √∫til la recursividad?",
          "options": [
            "Arrays lineales",
            "Estructuras de tipo arb√≥reo",
            "Tablas hash",
            "Matrices bidimensionales"
          ],
          "correctAnswer": 1,
          "explanation": "La recursividad es especialmente √∫til para estructuras de tipo arb√≥reo, donde se realizan las mismas operaciones en cada nodo hasta llegar a los elementos hojas."
        },
        {
          "id": 11,
          "type": "multiple_choice",
          "question": "¬øQu√© es la recursividad directa?",
          "options": [
            "Cuando una funci√≥n llama a otra funci√≥n diferente",
            "Cuando una funci√≥n o procedimiento √∫nicamente realiza una llamada recursiva a s√≠ misma",
            "Cuando se usan bucles en lugar de recursi√≥n",
            "Cuando se realizan m√∫ltiples llamadas a diferentes m√©todos"
          ],
          "correctAnswer": 1,
          "explanation": "La recursividad directa es cuando la funci√≥n o procedimiento √∫nicamente realiza una llamada recursiva a s√≠ misma, como en el ejemplo del factorial."
        },
        {
          "id": 12,
          "type": "multiple_choice",
          "question": "¬øQu√© caracteriza a la recursividad indirecta?",
          "options": [
            "Una funci√≥n se llama directamente a s√≠ misma",
            "Se realizan m√∫ltiples llamadas a diferentes m√©todos y en un punto se regresa a la llamada original",
            "Se usan √∫nicamente bucles for",
            "No se permite el uso de funciones"
          ],
          "correctAnswer": 1,
          "explanation": "La recursividad indirecta se caracteriza porque se realizan m√∫ltiples llamadas a diferentes m√©todos y en un punto determinado se regresa de nuevo a la llamada original, estableciendo un proceso recursivo."
        },
        {
          "id": 13,
          "type": "multiple_choice",
          "question": "¬øQu√© es la recursividad en aumento?",
          "options": [
            "Recursividad que aumenta el tama√±o del problema",
            "Recursividad donde se crean operaciones que se realizan despu√©s de la √∫ltima llamada recursiva",
            "Recursividad que solo funciona con n√∫meros positivos",
            "Recursividad que usa m√°s memoria progresivamente"
          ],
          "correctAnswer": 1,
          "explanation": "La recursividad en aumento es aquella donde se crean operaciones que tienen que realizarse despu√©s de que se efect√∫e la √∫ltima llamada recursiva, con llamadas diferidas en el tiempo."
        },
        {
          "id": 14,
          "type": "multiple_choice",
          "question": "¬øCu√°l es el principal problema de la recursividad m√∫ltiple?",
          "options": [
            "No puede resolver problemas complejos",
            "Puede producir desbordamiento de la pila antes de lo esperado",
            "Solo funciona con n√∫meros enteros",
            "Requiere hardware especial"
          ],
          "correctAnswer": 1,
          "explanation": "La recursividad m√∫ltiple puede producir desbordamiento de la pila antes de lo esperado porque cada llamada recursiva significa m√°s de una llamada en la realidad."
        },
        {
          "id": 15,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los tres aspectos principales del coste de una soluci√≥n recursiva?",
          "options": [
            "Velocidad, memoria y elegancia",
            "Esfuerzo de desarrollo, complejidad temporal y complejidad espacial",
            "Tiempo, espacio y recursi√≥n",
            "Hardware, software y programador"
          ],
          "correctAnswer": 1,
          "explanation": "Los tres aspectos principales del coste son: esfuerzo de desarrollo (tiempo para implementar), complejidad temporal (tiempo de ejecuci√≥n) y complejidad espacial (recursos de memoria)."
        },
        {
          "id": 16,
          "type": "multiple_choice",
          "question": "¬øQu√© problema espec√≠fico tiene la implementaci√≥n recursiva de Fibonacci?",
          "options": [
            "No puede calcular n√∫meros grandes",
            "Produce resultados incorrectos",
            "Puede causar desbordamiento de pila debido a la doble recursividad",
            "Solo funciona para n√∫meros pares"
          ],
          "correctAnswer": 2,
          "explanation": "La implementaci√≥n recursiva de Fibonacci puede causar desbordamiento de pila porque implica una doble recursividad en el caso general, realizando llamadas tanto para F(n-1) como F(n-2)."
        },
        {
          "id": 17,
          "type": "multiple_choice",
          "question": "¬øQu√© es un driver en el contexto de m√©todos recursivos?",
          "options": [
            "Un programa que maneja dispositivos de hardware",
            "Un m√©todo encargado de comprobar condiciones antes de llamar al m√©todo recursivo",
            "Una variable que cuenta las llamadas recursivas",
            "Un tipo especial de funci√≥n recursiva"
          ],
          "correctAnswer": 1,
          "explanation": "Un driver es un m√©todo encargado de comprobar las condiciones necesarias antes de llamar al m√©todo recursivo, evitando que la comprobaci√≥n se haga en todas las llamadas recursivas."
        },
        {
          "id": 18,
          "type": "multiple_choice",
          "question": "En el problema de las Torres de Hanoi, ¬øcu√°l es el caso base?",
          "options": [
            "Cuando hay m√°s de 3 discos",
            "Cuando numDiscos es 1, simplemente mover ese disco del origen al destino",
            "Cuando todos los discos est√°n en el poste auxiliar",
            "Cuando no quedan discos por mover"
          ],
          "correctAnswer": 1,
          "explanation": "El caso base en Torres de Hanoi es cuando numDiscos es 1, donde simplemente se mueve ese disco del poste de origen al poste de destino."
        },
        {
          "id": 19,
          "type": "multiple_choice",
          "question": "¬øCu√°les son los tres pasos del caso recursivo en Torres de Hanoi?",
          "options": [
            "Mover todos los discos al mismo tiempo",
            "Mover n-1 discos al auxiliar, mover el disco mayor al destino, mover n-1 discos del auxiliar al destino",
            "Mover un disco cada vez sin usar el poste auxiliar",
            "Contar los discos, organizarlos y moverlos"
          ],
          "correctAnswer": 1,
          "explanation": "Los tres pasos son: mover numDiscos-1 discos del origen al auxiliar, mover el disco m√°s grande al destino, y mover los numDiscos-1 discos del auxiliar al destino."
        },
        {
          "id": 20,
          "type": "multiple_choice",
          "question": "¬øQu√© significa que el desbordamiento de pila equivale a un bucle infinito en soluciones iterativas?",
          "options": [
            "Ambos problemas son exactamente iguales",
            "Ambos representan situaciones donde el algoritmo no puede terminar correctamente",
            "Solo ocurre en lenguajes interpretados",
            "Es un problema √∫nicamente de memoria"
          ],
          "correctAnswer": 1,
          "explanation": "El desbordamiento de pila en recursividad equivale a un bucle infinito en soluciones iterativas porque ambos representan situaciones donde el algoritmo no puede terminar correctamente debido a una condici√≥n de parada mal definida."
        },
        {
          "id": 21,
          "type": "multiple_choice",
          "question": "¬øPor qu√© es importante el dise√±o descendente en recursividad?",
          "options": [
            "Porque permite usar menos memoria",
            "Porque divide un problema mayor en subproblemas m√°s peque√±os, facilitando la implementaci√≥n recursiva",
            "Porque hace que el c√≥digo sea m√°s r√°pido",
            "Porque elimina la necesidad de casos base"
          ],
          "correctAnswer": 1,
          "explanation": "El dise√±o descendente es importante porque divide un problema mayor en subproblemas de tama√±o m√°s peque√±o, lo que est√° directamente relacionado con la recursividad al realizar llamadas con valores progresivamente menores."
        },
        {
          "id": 22,
          "type": "multiple_choice",
          "question": "¬øCu√°l es una desventaja significativa de las soluciones recursivas?",
          "options": [
            "Son siempre m√°s lentas que las iterativas",
            "No pueden resolver problemas complejos",
            "Pueden ser ineficientes generando gran n√∫mero de llamadas y abuso de memoria",
            "Solo funcionan en ciertos lenguajes de programaci√≥n"
          ],
          "correctAnswer": 2,
          "explanation": "Una desventaja significativa es que las implementaciones recursivas pueden ser ineficientes, generando gran n√∫mero de llamadas y creando un abuso de uso de memoria con variables duplicadas en cada llamada."
        },
        {
          "id": 23,
          "type": "multiple_choice",
          "question": "¬øQu√© ocurre durante la resoluci√≥n final en un proceso recursivo?",
          "options": [
            "Se reinicia todo el proceso",
            "Se eliminan todas las variables",
            "Cuando se llega al caso base, se comienzan a resolver todos los valores intermedios hasta proporcionar el resultado final",
            "Se cambia de recursividad a iteraci√≥n"
          ],
          "correctAnswer": 2,
          "explanation": "Durante la resoluci√≥n final, cuando el proceso recursivo llega al caso base, se comienzan a resolver todos los valores intermedios acumulados en la pila hasta proporcionar el resultado final."
        },
        {
          "id": 24,
          "type": "multiple_choice",
          "question": "¬øPor qu√© se menciona que algunos lenguajes √∫nicamente permiten recursividad?",
          "options": [
            "Porque son lenguajes defectuosos",
            "Para demostrar que la recursividad es una herramienta poderosa, ya que algunos lenguajes carecen de estructuras iterativas",
            "Porque son m√°s f√°ciles de programar",
            "Porque usan menos memoria"
          ],
          "correctAnswer": 1,
          "explanation": "Se menciona para demostrar que la recursividad es una de las herramientas m√°s potentes en programaci√≥n, tanto que algunos lenguajes √∫nicamente permiten recursividad y carecen completamente de estructuras iterativas."
        },
        {
          "id": 25,
          "type": "multiple_choice",
          "question": "¬øQu√© error t√≠pico puede causar problemas en recursividad?",
          "options": [
            "Usar variables locales",
            "La selecci√≥n incorrecta de la condici√≥n de parada del algoritmo",
            "Llamar a funciones externas",
            "Usar n√∫meros negativos"
          ],
          "correctAnswer": 1,
          "explanation": "Un error muy t√≠pico es la selecci√≥n incorrecta de la condici√≥n de parada del algoritmo, lo que puede llevar a desbordamiento de pila, uso innecesario de memoria, bloqueo del algoritmo o situaciones inestables."
        },
        {
          "id": 26,
          "type": "multiple_choice",
          "question": "¬øC√≥mo se optimiza el uso de drivers en m√©todos recursivos?",
          "options": [
            "Colocando la comprobaci√≥n dentro del m√©todo recursivo",
            "Realizando la comprobaci√≥n solo la primera vez que se invoca, antes de llamar al m√©todo recursivo",
            "Eliminando todas las comprobaciones",
            "Usando variables globales"
          ],
          "correctAnswer": 1,
          "explanation": "Se optimiza realizando la comprobaci√≥n solo la primera vez que se invoca mediante un driver, evitando que se compruebe la condici√≥n en todas las llamadas sucesivas al m√©todo recursivo."
        },
        {
          "id": 27,
          "type": "multiple_choice",
          "question": "En el ejemplo de suma recursiva, ¬øcu√°l es el caso base?",
          "options": [
            "s(0) = 0",
            "s(1) = 1",
            "s(n) = n",
            "s(n) = s(n-1) + n"
          ],
          "correctAnswer": 1,
          "explanation": "En el algoritmo de suma recursiva presentado, el caso base es s(1) = 1, donde la funci√≥n devuelve 1 cuando n es igual a 1."
        },
        {
          "id": 28,
          "type": "multiple_choice",
          "question": "¬øQu√© significa que la recursividad m√∫ltiple puede tener varios niveles de profundidad?",
          "options": [
            "Que puede usar m√°s memoria RAM",
            "Que m1 puede llamar a m2, m2 a m3, m3 a m4, y as√≠ sucesivamente hasta volver a m1",
            "Que solo funciona con n√∫meros grandes",
            "Que requiere compiladores especiales"
          ],
          "correctAnswer": 1,
          "explanation": "Significa que en la recursividad indirecta se pueden tener varios niveles de profundidad, donde m1 llama a m2, m2 a m3, m3 a m4, etc., hasta que eventualmente se vuelve a llamar a m1, creando un ciclo recursivo complejo."
        },
        {
          "id": 29,
          "type": "multiple_choice",
          "question": "¬øCu√°l es la principal recomendaci√≥n para el dise√±o de soluciones recursivas?",
          "options": [
            "Usar siempre recursividad m√∫ltiple",
            "Seguir la estrategia de la simplicidad y mantener las reglas del lenguaje de programaci√≥n",
            "Evitar los casos base",
            "Usar √∫nicamente variables globales"
          ],
          "correctAnswer": 1,
          "explanation": "La principal recomendaci√≥n es seguir la estrategia de la simplicidad, traduciendo el problema a un algoritmo manteniendo siempre las reglas del lenguaje de programaci√≥n que se est√© utilizando."
        },
        {
          "id": 30,
          "type": "multiple_choice",
          "question": "Seg√∫n el caso pr√°ctico del 'Coste desorbitado', ¬øcu√°l es la conclusi√≥n sobre el balance entre elegancia y rendimiento?",
          "options": [
            "La elegancia es siempre m√°s importante que el rendimiento",
            "Se debe priorizar mejorar el rendimiento sobre la elegancia cuando el usuario experimenta problemas de funcionamiento",
            "Nunca se debe usar recursividad en aplicaciones reales",
            "El rendimiento no es importante en programaci√≥n"
          ],
          "correctAnswer": 1,
          "explanation": "La conclusi√≥n es que se debe priorizar mejorar el rendimiento sobre la elegancia de la soluci√≥n cuando esto afecta la experiencia del usuario, ya que desde el punto de vista del usuario la implementaci√≥n es transparente y solo busca que el programa funcione correctamente."
        }
      ]
    }
  ]
}
